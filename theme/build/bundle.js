
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function () {
	'use strict';

	function createCommonjsModule(fn, basedir, module) {
		return module = {
			path: basedir,
			exports: {},
			require: function (path, base) {
				return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
			}
		}, fn(module, module.exports), module.exports;
	}

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
	}

	var lazysizes = createCommonjsModule(function (module) {
	(function(window, factory) {
		var lazySizes = factory(window, window.document, Date);
		window.lazySizes = lazySizes;
		if( module.exports){
			module.exports = lazySizes;
		}
	}(typeof window != 'undefined' ?
	      window : {}, function l(window, document, Date) { // Pass in the windoe Date function also for SSR because the Date class can be lost
		/*jshint eqnull:true */

		var lazysizes, lazySizesCfg;

		(function(){
			var prop;

			var lazySizesDefaults = {
				lazyClass: 'lazyload',
				loadedClass: 'lazyloaded',
				loadingClass: 'lazyloading',
				preloadClass: 'lazypreload',
				errorClass: 'lazyerror',
				//strictClass: 'lazystrict',
				autosizesClass: 'lazyautosizes',
				srcAttr: 'data-src',
				srcsetAttr: 'data-srcset',
				sizesAttr: 'data-sizes',
				//preloadAfterLoad: false,
				minSize: 40,
				customMedia: {},
				init: true,
				expFactor: 1.5,
				hFac: 0.8,
				loadMode: 2,
				loadHidden: true,
				ricTimeout: 0,
				throttleDelay: 125,
			};

			lazySizesCfg = window.lazySizesConfig || window.lazysizesConfig || {};

			for(prop in lazySizesDefaults){
				if(!(prop in lazySizesCfg)){
					lazySizesCfg[prop] = lazySizesDefaults[prop];
				}
			}
		})();

		if (!document || !document.getElementsByClassName) {
			return {
				init: function () {},
				cfg: lazySizesCfg,
				noSupport: true,
			};
		}

		var docElem = document.documentElement;

		var supportPicture = window.HTMLPictureElement;

		var _addEventListener = 'addEventListener';

		var _getAttribute = 'getAttribute';

		/**
		 * Update to bind to window because 'this' becomes null during SSR
		 * builds.
		 */
		var addEventListener = window[_addEventListener].bind(window);

		var setTimeout = window.setTimeout;

		var requestAnimationFrame = window.requestAnimationFrame || setTimeout;

		var requestIdleCallback = window.requestIdleCallback;

		var regPicture = /^picture$/i;

		var loadEvents = ['load', 'error', 'lazyincluded', '_lazyloaded'];

		var regClassCache = {};

		var forEach = Array.prototype.forEach;

		var hasClass = function(ele, cls) {
			if(!regClassCache[cls]){
				regClassCache[cls] = new RegExp('(\\s|^)'+cls+'(\\s|$)');
			}
			return regClassCache[cls].test(ele[_getAttribute]('class') || '') && regClassCache[cls];
		};

		var addClass = function(ele, cls) {
			if (!hasClass(ele, cls)){
				ele.setAttribute('class', (ele[_getAttribute]('class') || '').trim() + ' ' + cls);
			}
		};

		var removeClass = function(ele, cls) {
			var reg;
			if ((reg = hasClass(ele,cls))) {
				ele.setAttribute('class', (ele[_getAttribute]('class') || '').replace(reg, ' '));
			}
		};

		var addRemoveLoadEvents = function(dom, fn, add){
			var action = add ? _addEventListener : 'removeEventListener';
			if(add){
				addRemoveLoadEvents(dom, fn);
			}
			loadEvents.forEach(function(evt){
				dom[action](evt, fn);
			});
		};

		var triggerEvent = function(elem, name, detail, noBubbles, noCancelable){
			var event = document.createEvent('Event');

			if(!detail){
				detail = {};
			}

			detail.instance = lazysizes;

			event.initEvent(name, !noBubbles, !noCancelable);

			event.detail = detail;

			elem.dispatchEvent(event);
			return event;
		};

		var updatePolyfill = function (el, full){
			var polyfill;
			if( !supportPicture && ( polyfill = (window.picturefill || lazySizesCfg.pf) ) ){
				if(full && full.src && !el[_getAttribute]('srcset')){
					el.setAttribute('srcset', full.src);
				}
				polyfill({reevaluate: true, elements: [el]});
			} else if(full && full.src){
				el.src = full.src;
			}
		};

		var getCSS = function (elem, style){
			return (getComputedStyle(elem, null) || {})[style];
		};

		var getWidth = function(elem, parent, width){
			width = width || elem.offsetWidth;

			while(width < lazySizesCfg.minSize && parent && !elem._lazysizesWidth){
				width =  parent.offsetWidth;
				parent = parent.parentNode;
			}

			return width;
		};

		var rAF = (function(){
			var running, waiting;
			var firstFns = [];
			var secondFns = [];
			var fns = firstFns;

			var run = function(){
				var runFns = fns;

				fns = firstFns.length ? secondFns : firstFns;

				running = true;
				waiting = false;

				while(runFns.length){
					runFns.shift()();
				}

				running = false;
			};

			var rafBatch = function(fn, queue){
				if(running && !queue){
					fn.apply(this, arguments);
				} else {
					fns.push(fn);

					if(!waiting){
						waiting = true;
						(document.hidden ? setTimeout : requestAnimationFrame)(run);
					}
				}
			};

			rafBatch._lsFlush = run;

			return rafBatch;
		})();

		var rAFIt = function(fn, simple){
			return simple ?
				function() {
					rAF(fn);
				} :
				function(){
					var that = this;
					var args = arguments;
					rAF(function(){
						fn.apply(that, args);
					});
				}
			;
		};

		var throttle = function(fn){
			var running;
			var lastTime = 0;
			var gDelay = lazySizesCfg.throttleDelay;
			var rICTimeout = lazySizesCfg.ricTimeout;
			var run = function(){
				running = false;
				lastTime = Date.now();
				fn();
			};
			var idleCallback = requestIdleCallback && rICTimeout > 49 ?
				function(){
					requestIdleCallback(run, {timeout: rICTimeout});

					if(rICTimeout !== lazySizesCfg.ricTimeout){
						rICTimeout = lazySizesCfg.ricTimeout;
					}
				} :
				rAFIt(function(){
					setTimeout(run);
				}, true)
			;

			return function(isPriority){
				var delay;

				if((isPriority = isPriority === true)){
					rICTimeout = 33;
				}

				if(running){
					return;
				}

				running =  true;

				delay = gDelay - (Date.now() - lastTime);

				if(delay < 0){
					delay = 0;
				}

				if(isPriority || delay < 9){
					idleCallback();
				} else {
					setTimeout(idleCallback, delay);
				}
			};
		};

		//based on http://modernjavascript.blogspot.de/2013/08/building-better-debounce.html
		var debounce = function(func) {
			var timeout, timestamp;
			var wait = 99;
			var run = function(){
				timeout = null;
				func();
			};
			var later = function() {
				var last = Date.now() - timestamp;

				if (last < wait) {
					setTimeout(later, wait - last);
				} else {
					(requestIdleCallback || run)(run);
				}
			};

			return function() {
				timestamp = Date.now();

				if (!timeout) {
					timeout = setTimeout(later, wait);
				}
			};
		};

		var loader = (function(){
			var preloadElems, isCompleted, resetPreloadingTimer, loadMode, started;

			var eLvW, elvH, eLtop, eLleft, eLright, eLbottom, isBodyHidden;

			var regImg = /^img$/i;
			var regIframe = /^iframe$/i;

			var supportScroll = ('onscroll' in window) && !(/(gle|ing)bot/.test(navigator.userAgent));

			var shrinkExpand = 0;
			var currentExpand = 0;

			var isLoading = 0;
			var lowRuns = -1;

			var resetPreloading = function(e){
				isLoading--;
				if(!e || isLoading < 0 || !e.target){
					isLoading = 0;
				}
			};

			var isVisible = function (elem) {
				if (isBodyHidden == null) {
					isBodyHidden = getCSS(document.body, 'visibility') == 'hidden';
				}

				return isBodyHidden || !(getCSS(elem.parentNode, 'visibility') == 'hidden' && getCSS(elem, 'visibility') == 'hidden');
			};

			var isNestedVisible = function(elem, elemExpand){
				var outerRect;
				var parent = elem;
				var visible = isVisible(elem);

				eLtop -= elemExpand;
				eLbottom += elemExpand;
				eLleft -= elemExpand;
				eLright += elemExpand;

				while(visible && (parent = parent.offsetParent) && parent != document.body && parent != docElem){
					visible = ((getCSS(parent, 'opacity') || 1) > 0);

					if(visible && getCSS(parent, 'overflow') != 'visible'){
						outerRect = parent.getBoundingClientRect();
						visible = eLright > outerRect.left &&
							eLleft < outerRect.right &&
							eLbottom > outerRect.top - 1 &&
							eLtop < outerRect.bottom + 1
						;
					}
				}

				return visible;
			};

			var checkElements = function() {
				var eLlen, i, rect, autoLoadElem, loadedSomething, elemExpand, elemNegativeExpand, elemExpandVal,
					beforeExpandVal, defaultExpand, preloadExpand, hFac;
				var lazyloadElems = lazysizes.elements;

				if((loadMode = lazySizesCfg.loadMode) && isLoading < 8 && (eLlen = lazyloadElems.length)){

					i = 0;

					lowRuns++;

					for(; i < eLlen; i++){

						if(!lazyloadElems[i] || lazyloadElems[i]._lazyRace){continue;}

						if(!supportScroll || (lazysizes.prematureUnveil && lazysizes.prematureUnveil(lazyloadElems[i]))){unveilElement(lazyloadElems[i]);continue;}

						if(!(elemExpandVal = lazyloadElems[i][_getAttribute]('data-expand')) || !(elemExpand = elemExpandVal * 1)){
							elemExpand = currentExpand;
						}

						if (!defaultExpand) {
							defaultExpand = (!lazySizesCfg.expand || lazySizesCfg.expand < 1) ?
								docElem.clientHeight > 500 && docElem.clientWidth > 500 ? 500 : 370 :
								lazySizesCfg.expand;

							lazysizes._defEx = defaultExpand;

							preloadExpand = defaultExpand * lazySizesCfg.expFactor;
							hFac = lazySizesCfg.hFac;
							isBodyHidden = null;

							if(currentExpand < preloadExpand && isLoading < 1 && lowRuns > 2 && loadMode > 2 && !document.hidden){
								currentExpand = preloadExpand;
								lowRuns = 0;
							} else if(loadMode > 1 && lowRuns > 1 && isLoading < 6){
								currentExpand = defaultExpand;
							} else {
								currentExpand = shrinkExpand;
							}
						}

						if(beforeExpandVal !== elemExpand){
							eLvW = innerWidth + (elemExpand * hFac);
							elvH = innerHeight + elemExpand;
							elemNegativeExpand = elemExpand * -1;
							beforeExpandVal = elemExpand;
						}

						rect = lazyloadElems[i].getBoundingClientRect();

						if ((eLbottom = rect.bottom) >= elemNegativeExpand &&
							(eLtop = rect.top) <= elvH &&
							(eLright = rect.right) >= elemNegativeExpand * hFac &&
							(eLleft = rect.left) <= eLvW &&
							(eLbottom || eLright || eLleft || eLtop) &&
							(lazySizesCfg.loadHidden || isVisible(lazyloadElems[i])) &&
							((isCompleted && isLoading < 3 && !elemExpandVal && (loadMode < 3 || lowRuns < 4)) || isNestedVisible(lazyloadElems[i], elemExpand))){
							unveilElement(lazyloadElems[i]);
							loadedSomething = true;
							if(isLoading > 9){break;}
						} else if(!loadedSomething && isCompleted && !autoLoadElem &&
							isLoading < 4 && lowRuns < 4 && loadMode > 2 &&
							(preloadElems[0] || lazySizesCfg.preloadAfterLoad) &&
							(preloadElems[0] || (!elemExpandVal && ((eLbottom || eLright || eLleft || eLtop) || lazyloadElems[i][_getAttribute](lazySizesCfg.sizesAttr) != 'auto')))){
							autoLoadElem = preloadElems[0] || lazyloadElems[i];
						}
					}

					if(autoLoadElem && !loadedSomething){
						unveilElement(autoLoadElem);
					}
				}
			};

			var throttledCheckElements = throttle(checkElements);

			var switchLoadingClass = function(e){
				var elem = e.target;

				if (elem._lazyCache) {
					delete elem._lazyCache;
					return;
				}

				resetPreloading(e);
				addClass(elem, lazySizesCfg.loadedClass);
				removeClass(elem, lazySizesCfg.loadingClass);
				addRemoveLoadEvents(elem, rafSwitchLoadingClass);
				triggerEvent(elem, 'lazyloaded');
			};
			var rafedSwitchLoadingClass = rAFIt(switchLoadingClass);
			var rafSwitchLoadingClass = function(e){
				rafedSwitchLoadingClass({target: e.target});
			};

			var changeIframeSrc = function(elem, src){
				try {
					elem.contentWindow.location.replace(src);
				} catch(e){
					elem.src = src;
				}
			};

			var handleSources = function(source){
				var customMedia;

				var sourceSrcset = source[_getAttribute](lazySizesCfg.srcsetAttr);

				if( (customMedia = lazySizesCfg.customMedia[source[_getAttribute]('data-media') || source[_getAttribute]('media')]) ){
					source.setAttribute('media', customMedia);
				}

				if(sourceSrcset){
					source.setAttribute('srcset', sourceSrcset);
				}
			};

			var lazyUnveil = rAFIt(function (elem, detail, isAuto, sizes, isImg){
				var src, srcset, parent, isPicture, event, firesLoad;

				if(!(event = triggerEvent(elem, 'lazybeforeunveil', detail)).defaultPrevented){

					if(sizes){
						if(isAuto){
							addClass(elem, lazySizesCfg.autosizesClass);
						} else {
							elem.setAttribute('sizes', sizes);
						}
					}

					srcset = elem[_getAttribute](lazySizesCfg.srcsetAttr);
					src = elem[_getAttribute](lazySizesCfg.srcAttr);

					if(isImg) {
						parent = elem.parentNode;
						isPicture = parent && regPicture.test(parent.nodeName || '');
					}

					firesLoad = detail.firesLoad || (('src' in elem) && (srcset || src || isPicture));

					event = {target: elem};

					addClass(elem, lazySizesCfg.loadingClass);

					if(firesLoad){
						clearTimeout(resetPreloadingTimer);
						resetPreloadingTimer = setTimeout(resetPreloading, 2500);
						addRemoveLoadEvents(elem, rafSwitchLoadingClass, true);
					}

					if(isPicture){
						forEach.call(parent.getElementsByTagName('source'), handleSources);
					}

					if(srcset){
						elem.setAttribute('srcset', srcset);
					} else if(src && !isPicture){
						if(regIframe.test(elem.nodeName)){
							changeIframeSrc(elem, src);
						} else {
							elem.src = src;
						}
					}

					if(isImg && (srcset || isPicture)){
						updatePolyfill(elem, {src: src});
					}
				}

				if(elem._lazyRace){
					delete elem._lazyRace;
				}
				removeClass(elem, lazySizesCfg.lazyClass);

				rAF(function(){
					// Part of this can be removed as soon as this fix is older: https://bugs.chromium.org/p/chromium/issues/detail?id=7731 (2015)
					var isLoaded = elem.complete && elem.naturalWidth > 1;

					if( !firesLoad || isLoaded){
						if (isLoaded) {
							addClass(elem, 'ls-is-cached');
						}
						switchLoadingClass(event);
						elem._lazyCache = true;
						setTimeout(function(){
							if ('_lazyCache' in elem) {
								delete elem._lazyCache;
							}
						}, 9);
					}
					if (elem.loading == 'lazy') {
						isLoading--;
					}
				}, true);
			});

			var unveilElement = function (elem){
				if (elem._lazyRace) {return;}
				var detail;

				var isImg = regImg.test(elem.nodeName);

				//allow using sizes="auto", but don't use. it's invalid. Use data-sizes="auto" or a valid value for sizes instead (i.e.: sizes="80vw")
				var sizes = isImg && (elem[_getAttribute](lazySizesCfg.sizesAttr) || elem[_getAttribute]('sizes'));
				var isAuto = sizes == 'auto';

				if( (isAuto || !isCompleted) && isImg && (elem[_getAttribute]('src') || elem.srcset) && !elem.complete && !hasClass(elem, lazySizesCfg.errorClass) && hasClass(elem, lazySizesCfg.lazyClass)){return;}

				detail = triggerEvent(elem, 'lazyunveilread').detail;

				if(isAuto){
					 autoSizer.updateElem(elem, true, elem.offsetWidth);
				}

				elem._lazyRace = true;
				isLoading++;

				lazyUnveil(elem, detail, isAuto, sizes, isImg);
			};

			var afterScroll = debounce(function(){
				lazySizesCfg.loadMode = 3;
				throttledCheckElements();
			});

			var altLoadmodeScrollListner = function(){
				if(lazySizesCfg.loadMode == 3){
					lazySizesCfg.loadMode = 2;
				}
				afterScroll();
			};

			var onload = function(){
				if(isCompleted){return;}
				if(Date.now() - started < 999){
					setTimeout(onload, 999);
					return;
				}


				isCompleted = true;

				lazySizesCfg.loadMode = 3;

				throttledCheckElements();

				addEventListener('scroll', altLoadmodeScrollListner, true);
			};

			return {
				_: function(){
					started = Date.now();

					lazysizes.elements = document.getElementsByClassName(lazySizesCfg.lazyClass);
					preloadElems = document.getElementsByClassName(lazySizesCfg.lazyClass + ' ' + lazySizesCfg.preloadClass);

					addEventListener('scroll', throttledCheckElements, true);

					addEventListener('resize', throttledCheckElements, true);

					addEventListener('pageshow', function (e) {
						if (e.persisted) {
							var loadingElements = document.querySelectorAll('.' + lazySizesCfg.loadingClass);

							if (loadingElements.length && loadingElements.forEach) {
								requestAnimationFrame(function () {
									loadingElements.forEach( function (img) {
										if (img.complete) {
											unveilElement(img);
										}
									});
								});
							}
						}
					});

					if(window.MutationObserver){
						new MutationObserver( throttledCheckElements ).observe( docElem, {childList: true, subtree: true, attributes: true} );
					} else {
						docElem[_addEventListener]('DOMNodeInserted', throttledCheckElements, true);
						docElem[_addEventListener]('DOMAttrModified', throttledCheckElements, true);
						setInterval(throttledCheckElements, 999);
					}

					addEventListener('hashchange', throttledCheckElements, true);

					//, 'fullscreenchange'
					['focus', 'mouseover', 'click', 'load', 'transitionend', 'animationend'].forEach(function(name){
						document[_addEventListener](name, throttledCheckElements, true);
					});

					if((/d$|^c/.test(document.readyState))){
						onload();
					} else {
						addEventListener('load', onload);
						document[_addEventListener]('DOMContentLoaded', throttledCheckElements);
						setTimeout(onload, 20000);
					}

					if(lazysizes.elements.length){
						checkElements();
						rAF._lsFlush();
					} else {
						throttledCheckElements();
					}
				},
				checkElems: throttledCheckElements,
				unveil: unveilElement,
				_aLSL: altLoadmodeScrollListner,
			};
		})();


		var autoSizer = (function(){
			var autosizesElems;

			var sizeElement = rAFIt(function(elem, parent, event, width){
				var sources, i, len;
				elem._lazysizesWidth = width;
				width += 'px';

				elem.setAttribute('sizes', width);

				if(regPicture.test(parent.nodeName || '')){
					sources = parent.getElementsByTagName('source');
					for(i = 0, len = sources.length; i < len; i++){
						sources[i].setAttribute('sizes', width);
					}
				}

				if(!event.detail.dataAttr){
					updatePolyfill(elem, event.detail);
				}
			});
			var getSizeElement = function (elem, dataAttr, width){
				var event;
				var parent = elem.parentNode;

				if(parent){
					width = getWidth(elem, parent, width);
					event = triggerEvent(elem, 'lazybeforesizes', {width: width, dataAttr: !!dataAttr});

					if(!event.defaultPrevented){
						width = event.detail.width;

						if(width && width !== elem._lazysizesWidth){
							sizeElement(elem, parent, event, width);
						}
					}
				}
			};

			var updateElementsSizes = function(){
				var i;
				var len = autosizesElems.length;
				if(len){
					i = 0;

					for(; i < len; i++){
						getSizeElement(autosizesElems[i]);
					}
				}
			};

			var debouncedUpdateElementsSizes = debounce(updateElementsSizes);

			return {
				_: function(){
					autosizesElems = document.getElementsByClassName(lazySizesCfg.autosizesClass);
					addEventListener('resize', debouncedUpdateElementsSizes);
				},
				checkElems: debouncedUpdateElementsSizes,
				updateElem: getSizeElement
			};
		})();

		var init = function(){
			if(!init.i && document.getElementsByClassName){
				init.i = true;
				autoSizer._();
				loader._();
			}
		};

		setTimeout(function(){
			if(lazySizesCfg.init){
				init();
			}
		});

		lazysizes = {
			cfg: lazySizesCfg,
			autoSizer: autoSizer,
			loader: loader,
			init: init,
			uP: updatePolyfill,
			aC: addClass,
			rC: removeClass,
			hC: hasClass,
			fire: triggerEvent,
			gW: getWidth,
			rAF: rAF,
		};

		return lazysizes;
	}
	));
	});

	function noop() { }
	function assign(tar, src) {
	    // @ts-ignore
	    for (const k in src)
	        tar[k] = src[k];
	    return tar;
	}
	function add_location(element, file, line, column, char) {
	    element.__svelte_meta = {
	        loc: { file, line, column, char }
	    };
	}
	function run(fn) {
	    return fn();
	}
	function blank_object() {
	    return Object.create(null);
	}
	function run_all(fns) {
	    fns.forEach(run);
	}
	function is_function(thing) {
	    return typeof thing === 'function';
	}
	function safe_not_equal(a, b) {
	    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
	}
	function is_empty(obj) {
	    return Object.keys(obj).length === 0;
	}
	function validate_store(store, name) {
	    if (store != null && typeof store.subscribe !== 'function') {
	        throw new Error(`'${name}' is not a store with a 'subscribe' method`);
	    }
	}
	function subscribe(store, ...callbacks) {
	    if (store == null) {
	        return noop;
	    }
	    const unsub = store.subscribe(...callbacks);
	    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
	}
	function component_subscribe(component, store, callback) {
	    component.$$.on_destroy.push(subscribe(store, callback));
	}
	function create_slot(definition, ctx, $$scope, fn) {
	    if (definition) {
	        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
	        return definition[0](slot_ctx);
	    }
	}
	function get_slot_context(definition, ctx, $$scope, fn) {
	    return definition[1] && fn
	        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
	        : $$scope.ctx;
	}
	function get_slot_changes(definition, $$scope, dirty, fn) {
	    if (definition[2] && fn) {
	        const lets = definition[2](fn(dirty));
	        if ($$scope.dirty === undefined) {
	            return lets;
	        }
	        if (typeof lets === 'object') {
	            const merged = [];
	            const len = Math.max($$scope.dirty.length, lets.length);
	            for (let i = 0; i < len; i += 1) {
	                merged[i] = $$scope.dirty[i] | lets[i];
	            }
	            return merged;
	        }
	        return $$scope.dirty | lets;
	    }
	    return $$scope.dirty;
	}
	function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
	    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
	    if (slot_changes) {
	        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
	        slot.p(slot_context, slot_changes);
	    }
	}
	function exclude_internal_props(props) {
	    const result = {};
	    for (const k in props)
	        if (k[0] !== '$')
	            result[k] = props[k];
	    return result;
	}

	function append(target, node) {
	    target.appendChild(node);
	}
	function insert(target, node, anchor) {
	    target.insertBefore(node, anchor || null);
	}
	function detach(node) {
	    node.parentNode.removeChild(node);
	}
	function destroy_each(iterations, detaching) {
	    for (let i = 0; i < iterations.length; i += 1) {
	        if (iterations[i])
	            iterations[i].d(detaching);
	    }
	}
	function element(name) {
	    return document.createElement(name);
	}
	function text(data) {
	    return document.createTextNode(data);
	}
	function space() {
	    return text(' ');
	}
	function empty() {
	    return text('');
	}
	function listen(node, event, handler, options) {
	    node.addEventListener(event, handler, options);
	    return () => node.removeEventListener(event, handler, options);
	}
	function attr(node, attribute, value) {
	    if (value == null)
	        node.removeAttribute(attribute);
	    else if (node.getAttribute(attribute) !== value)
	        node.setAttribute(attribute, value);
	}
	function set_attributes(node, attributes) {
	    // @ts-ignore
	    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
	    for (const key in attributes) {
	        if (attributes[key] == null) {
	            node.removeAttribute(key);
	        }
	        else if (key === 'style') {
	            node.style.cssText = attributes[key];
	        }
	        else if (key === '__value') {
	            node.value = node[key] = attributes[key];
	        }
	        else if (descriptors[key] && descriptors[key].set) {
	            node[key] = attributes[key];
	        }
	        else {
	            attr(node, key, attributes[key]);
	        }
	    }
	}
	function children(element) {
	    return Array.from(element.childNodes);
	}
	function custom_event(type, detail) {
	    const e = document.createEvent('CustomEvent');
	    e.initCustomEvent(type, false, false, detail);
	    return e;
	}

	let current_component;
	function set_current_component(component) {
	    current_component = component;
	}
	function get_current_component() {
	    if (!current_component)
	        throw new Error('Function called outside component initialization');
	    return current_component;
	}
	function onMount(fn) {
	    get_current_component().$$.on_mount.push(fn);
	}
	function onDestroy(fn) {
	    get_current_component().$$.on_destroy.push(fn);
	}
	function createEventDispatcher() {
	    const component = get_current_component();
	    return (type, detail) => {
	        const callbacks = component.$$.callbacks[type];
	        if (callbacks) {
	            // TODO are there situations where events could be dispatched
	            // in a server (non-DOM) environment?
	            const event = custom_event(type, detail);
	            callbacks.slice().forEach(fn => {
	                fn.call(component, event);
	            });
	        }
	    };
	}
	function setContext(key, context) {
	    get_current_component().$$.context.set(key, context);
	}
	function getContext(key) {
	    return get_current_component().$$.context.get(key);
	}

	const dirty_components = [];
	const binding_callbacks = [];
	const render_callbacks = [];
	const flush_callbacks = [];
	const resolved_promise = Promise.resolve();
	let update_scheduled = false;
	function schedule_update() {
	    if (!update_scheduled) {
	        update_scheduled = true;
	        resolved_promise.then(flush);
	    }
	}
	function add_render_callback(fn) {
	    render_callbacks.push(fn);
	}
	let flushing = false;
	const seen_callbacks = new Set();
	function flush() {
	    if (flushing)
	        return;
	    flushing = true;
	    do {
	        // first, call beforeUpdate functions
	        // and update components
	        for (let i = 0; i < dirty_components.length; i += 1) {
	            const component = dirty_components[i];
	            set_current_component(component);
	            update(component.$$);
	        }
	        set_current_component(null);
	        dirty_components.length = 0;
	        while (binding_callbacks.length)
	            binding_callbacks.pop()();
	        // then, once components are updated, call
	        // afterUpdate functions. This may cause
	        // subsequent updates...
	        for (let i = 0; i < render_callbacks.length; i += 1) {
	            const callback = render_callbacks[i];
	            if (!seen_callbacks.has(callback)) {
	                // ...so guard against infinite loops
	                seen_callbacks.add(callback);
	                callback();
	            }
	        }
	        render_callbacks.length = 0;
	    } while (dirty_components.length);
	    while (flush_callbacks.length) {
	        flush_callbacks.pop()();
	    }
	    update_scheduled = false;
	    flushing = false;
	    seen_callbacks.clear();
	}
	function update($$) {
	    if ($$.fragment !== null) {
	        $$.update();
	        run_all($$.before_update);
	        const dirty = $$.dirty;
	        $$.dirty = [-1];
	        $$.fragment && $$.fragment.p($$.ctx, dirty);
	        $$.after_update.forEach(add_render_callback);
	    }
	}
	const outroing = new Set();
	let outros;
	function group_outros() {
	    outros = {
	        r: 0,
	        c: [],
	        p: outros // parent group
	    };
	}
	function check_outros() {
	    if (!outros.r) {
	        run_all(outros.c);
	    }
	    outros = outros.p;
	}
	function transition_in(block, local) {
	    if (block && block.i) {
	        outroing.delete(block);
	        block.i(local);
	    }
	}
	function transition_out(block, local, detach, callback) {
	    if (block && block.o) {
	        if (outroing.has(block))
	            return;
	        outroing.add(block);
	        outros.c.push(() => {
	            outroing.delete(block);
	            if (callback) {
	                if (detach)
	                    block.d(1);
	                callback();
	            }
	        });
	        block.o(local);
	    }
	}

	function get_spread_update(levels, updates) {
	    const update = {};
	    const to_null_out = {};
	    const accounted_for = { $$scope: 1 };
	    let i = levels.length;
	    while (i--) {
	        const o = levels[i];
	        const n = updates[i];
	        if (n) {
	            for (const key in o) {
	                if (!(key in n))
	                    to_null_out[key] = 1;
	            }
	            for (const key in n) {
	                if (!accounted_for[key]) {
	                    update[key] = n[key];
	                    accounted_for[key] = 1;
	                }
	            }
	            levels[i] = n;
	        }
	        else {
	            for (const key in o) {
	                accounted_for[key] = 1;
	            }
	        }
	    }
	    for (const key in to_null_out) {
	        if (!(key in update))
	            update[key] = undefined;
	    }
	    return update;
	}
	function get_spread_object(spread_props) {
	    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
	}
	function create_component(block) {
	    block && block.c();
	}
	function mount_component(component, target, anchor) {
	    const { fragment, on_mount, on_destroy, after_update } = component.$$;
	    fragment && fragment.m(target, anchor);
	    // onMount happens before the initial afterUpdate
	    add_render_callback(() => {
	        const new_on_destroy = on_mount.map(run).filter(is_function);
	        if (on_destroy) {
	            on_destroy.push(...new_on_destroy);
	        }
	        else {
	            // Edge case - component was destroyed immediately,
	            // most likely as a result of a binding initialising
	            run_all(new_on_destroy);
	        }
	        component.$$.on_mount = [];
	    });
	    after_update.forEach(add_render_callback);
	}
	function destroy_component(component, detaching) {
	    const $$ = component.$$;
	    if ($$.fragment !== null) {
	        run_all($$.on_destroy);
	        $$.fragment && $$.fragment.d(detaching);
	        // TODO null out other refs, including component.$$ (but need to
	        // preserve final state?)
	        $$.on_destroy = $$.fragment = null;
	        $$.ctx = [];
	    }
	}
	function make_dirty(component, i) {
	    if (component.$$.dirty[0] === -1) {
	        dirty_components.push(component);
	        schedule_update();
	        component.$$.dirty.fill(0);
	    }
	    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
	}
	function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
	    const parent_component = current_component;
	    set_current_component(component);
	    const prop_values = options.props || {};
	    const $$ = component.$$ = {
	        fragment: null,
	        ctx: null,
	        // state
	        props,
	        update: noop,
	        not_equal,
	        bound: blank_object(),
	        // lifecycle
	        on_mount: [],
	        on_destroy: [],
	        before_update: [],
	        after_update: [],
	        context: new Map(parent_component ? parent_component.$$.context : []),
	        // everything else
	        callbacks: blank_object(),
	        dirty,
	        skip_bound: false
	    };
	    let ready = false;
	    $$.ctx = instance
	        ? instance(component, prop_values, (i, ret, ...rest) => {
	            const value = rest.length ? rest[0] : ret;
	            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
	                if (!$$.skip_bound && $$.bound[i])
	                    $$.bound[i](value);
	                if (ready)
	                    make_dirty(component, i);
	            }
	            return ret;
	        })
	        : [];
	    $$.update();
	    ready = true;
	    run_all($$.before_update);
	    // `false` as a special case of no DOM component
	    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
	    if (options.target) {
	        if (options.hydrate) {
	            const nodes = children(options.target);
	            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	            $$.fragment && $$.fragment.l(nodes);
	            nodes.forEach(detach);
	        }
	        else {
	            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	            $$.fragment && $$.fragment.c();
	        }
	        if (options.intro)
	            transition_in(component.$$.fragment);
	        mount_component(component, options.target, options.anchor);
	        flush();
	    }
	    set_current_component(parent_component);
	}
	class SvelteComponent {
	    $destroy() {
	        destroy_component(this, 1);
	        this.$destroy = noop;
	    }
	    $on(type, callback) {
	        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
	        callbacks.push(callback);
	        return () => {
	            const index = callbacks.indexOf(callback);
	            if (index !== -1)
	                callbacks.splice(index, 1);
	        };
	    }
	    $set($$props) {
	        if (this.$$set && !is_empty($$props)) {
	            this.$$.skip_bound = true;
	            this.$$set($$props);
	            this.$$.skip_bound = false;
	        }
	    }
	}

	function dispatch_dev(type, detail) {
	    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.30.0' }, detail)));
	}
	function append_dev(target, node) {
	    dispatch_dev('SvelteDOMInsert', { target, node });
	    append(target, node);
	}
	function insert_dev(target, node, anchor) {
	    dispatch_dev('SvelteDOMInsert', { target, node, anchor });
	    insert(target, node, anchor);
	}
	function detach_dev(node) {
	    dispatch_dev('SvelteDOMRemove', { node });
	    detach(node);
	}
	function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
	    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
	    if (has_prevent_default)
	        modifiers.push('preventDefault');
	    if (has_stop_propagation)
	        modifiers.push('stopPropagation');
	    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
	    const dispose = listen(node, event, handler, options);
	    return () => {
	        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
	        dispose();
	    };
	}
	function attr_dev(node, attribute, value) {
	    attr(node, attribute, value);
	    if (value == null)
	        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
	    else
	        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
	}
	function set_data_dev(text, data) {
	    data = '' + data;
	    if (text.wholeText === data)
	        return;
	    dispatch_dev('SvelteDOMSetData', { node: text, data });
	    text.data = data;
	}
	function validate_each_argument(arg) {
	    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
	        let msg = '{#each} only iterates over array-like objects.';
	        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
	            msg += ' You can use a spread to convert this iterable into an array.';
	        }
	        throw new Error(msg);
	    }
	}
	function validate_slots(name, slot, keys) {
	    for (const slot_key of Object.keys(slot)) {
	        if (!~keys.indexOf(slot_key)) {
	            console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
	        }
	    }
	}
	class SvelteComponentDev extends SvelteComponent {
	    constructor(options) {
	        if (!options || (!options.target && !options.$$inline)) {
	            throw new Error("'target' is a required option");
	        }
	        super();
	    }
	    $destroy() {
	        super.$destroy();
	        this.$destroy = () => {
	            console.warn('Component was already destroyed'); // eslint-disable-line no-console
	        };
	    }
	    $capture_state() { }
	    $inject_state() { }
	}

	const subscriber_queue = [];
	/**
	 * Creates a `Readable` store that allows reading by subscription.
	 * @param value initial value
	 * @param {StartStopNotifier}start start and stop notifications for subscriptions
	 */
	function readable(value, start) {
	    return {
	        subscribe: writable(value, start).subscribe
	    };
	}
	/**
	 * Create a `Writable` store that allows both updating and reading by subscription.
	 * @param {*=}value initial value
	 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
	 */
	function writable(value, start = noop) {
	    let stop;
	    const subscribers = [];
	    function set(new_value) {
	        if (safe_not_equal(value, new_value)) {
	            value = new_value;
	            if (stop) { // store is ready
	                const run_queue = !subscriber_queue.length;
	                for (let i = 0; i < subscribers.length; i += 1) {
	                    const s = subscribers[i];
	                    s[1]();
	                    subscriber_queue.push(s, value);
	                }
	                if (run_queue) {
	                    for (let i = 0; i < subscriber_queue.length; i += 2) {
	                        subscriber_queue[i][0](subscriber_queue[i + 1]);
	                    }
	                    subscriber_queue.length = 0;
	                }
	            }
	        }
	    }
	    function update(fn) {
	        set(fn(value));
	    }
	    function subscribe(run, invalidate = noop) {
	        const subscriber = [run, invalidate];
	        subscribers.push(subscriber);
	        if (subscribers.length === 1) {
	            stop = start(set) || noop;
	        }
	        run(value);
	        return () => {
	            const index = subscribers.indexOf(subscriber);
	            if (index !== -1) {
	                subscribers.splice(index, 1);
	            }
	            if (subscribers.length === 0) {
	                stop();
	                stop = null;
	            }
	        };
	    }
	    return { set, update, subscribe };
	}
	function derived(stores, fn, initial_value) {
	    const single = !Array.isArray(stores);
	    const stores_array = single
	        ? [stores]
	        : stores;
	    const auto = fn.length < 2;
	    return readable(initial_value, (set) => {
	        let inited = false;
	        const values = [];
	        let pending = 0;
	        let cleanup = noop;
	        const sync = () => {
	            if (pending) {
	                return;
	            }
	            cleanup();
	            const result = fn(single ? values[0] : values, set);
	            if (auto) {
	                set(result);
	            }
	            else {
	                cleanup = is_function(result) ? result : noop;
	            }
	        };
	        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
	            values[i] = value;
	            pending &= ~(1 << i);
	            if (inited) {
	                sync();
	            }
	        }, () => {
	            pending |= (1 << i);
	        }));
	        inited = true;
	        sync();
	        return function stop() {
	            run_all(unsubscribers);
	            cleanup();
	        };
	    });
	}

	const LOCATION = {};
	const ROUTER = {};

	/**
	 * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/history.js
	 *
	 * https://github.com/reach/router/blob/master/LICENSE
	 * */

	function getLocation(source) {
	  return {
	    ...source.location,
	    state: source.history.state,
	    key: (source.history.state && source.history.state.key) || "initial"
	  };
	}

	function createHistory(source, options) {
	  const listeners = [];
	  let location = getLocation(source);

	  return {
	    get location() {
	      return location;
	    },

	    listen(listener) {
	      listeners.push(listener);

	      const popstateListener = () => {
	        location = getLocation(source);
	        listener({ location, action: "POP" });
	      };

	      source.addEventListener("popstate", popstateListener);

	      return () => {
	        source.removeEventListener("popstate", popstateListener);

	        const index = listeners.indexOf(listener);
	        listeners.splice(index, 1);
	      };
	    },

	    navigate(to, { state, replace = false } = {}) {
	      state = { ...state, key: Date.now() + "" };
	      // try...catch iOS Safari limits to 100 pushState calls
	      try {
	        if (replace) {
	          source.history.replaceState(state, null, to);
	        } else {
	          source.history.pushState(state, null, to);
	        }
	      } catch (e) {
	        source.location[replace ? "replace" : "assign"](to);
	      }

	      location = getLocation(source);
	      listeners.forEach(listener => listener({ location, action: "PUSH" }));
	    }
	  };
	}

	// Stores history entries in memory for testing or other platforms like Native
	function createMemorySource(initialPathname = "/") {
	  let index = 0;
	  const stack = [{ pathname: initialPathname, search: "" }];
	  const states = [];

	  return {
	    get location() {
	      return stack[index];
	    },
	    addEventListener(name, fn) {},
	    removeEventListener(name, fn) {},
	    history: {
	      get entries() {
	        return stack;
	      },
	      get index() {
	        return index;
	      },
	      get state() {
	        return states[index];
	      },
	      pushState(state, _, uri) {
	        const [pathname, search = ""] = uri.split("?");
	        index++;
	        stack.push({ pathname, search });
	        states.push(state);
	      },
	      replaceState(state, _, uri) {
	        const [pathname, search = ""] = uri.split("?");
	        stack[index] = { pathname, search };
	        states[index] = state;
	      }
	    }
	  };
	}

	// Global history uses window.history as the source if available,
	// otherwise a memory history
	const canUseDOM = Boolean(
	  typeof window !== "undefined" &&
	    window.document &&
	    window.document.createElement
	);
	const globalHistory = createHistory(canUseDOM ? window : createMemorySource());
	const { navigate } = globalHistory;

	/**
	 * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/utils.js
	 *
	 * https://github.com/reach/router/blob/master/LICENSE
	 * */

	const paramRe = /^:(.+)/;

	const SEGMENT_POINTS = 4;
	const STATIC_POINTS = 3;
	const DYNAMIC_POINTS = 2;
	const SPLAT_PENALTY = 1;
	const ROOT_POINTS = 1;

	/**
	 * Check if `string` starts with `search`
	 * @param {string} string
	 * @param {string} search
	 * @return {boolean}
	 */
	function startsWith(string, search) {
	  return string.substr(0, search.length) === search;
	}

	/**
	 * Check if `segment` is a root segment
	 * @param {string} segment
	 * @return {boolean}
	 */
	function isRootSegment(segment) {
	  return segment === "";
	}

	/**
	 * Check if `segment` is a dynamic segment
	 * @param {string} segment
	 * @return {boolean}
	 */
	function isDynamic(segment) {
	  return paramRe.test(segment);
	}

	/**
	 * Check if `segment` is a splat
	 * @param {string} segment
	 * @return {boolean}
	 */
	function isSplat(segment) {
	  return segment[0] === "*";
	}

	/**
	 * Split up the URI into segments delimited by `/`
	 * @param {string} uri
	 * @return {string[]}
	 */
	function segmentize(uri) {
	  return (
	    uri
	      // Strip starting/ending `/`
	      .replace(/(^\/+|\/+$)/g, "")
	      .split("/")
	  );
	}

	/**
	 * Strip `str` of potential start and end `/`
	 * @param {string} str
	 * @return {string}
	 */
	function stripSlashes(str) {
	  return str.replace(/(^\/+|\/+$)/g, "");
	}

	/**
	 * Score a route depending on how its individual segments look
	 * @param {object} route
	 * @param {number} index
	 * @return {object}
	 */
	function rankRoute(route, index) {
	  const score = route.default
	    ? 0
	    : segmentize(route.path).reduce((score, segment) => {
	        score += SEGMENT_POINTS;

	        if (isRootSegment(segment)) {
	          score += ROOT_POINTS;
	        } else if (isDynamic(segment)) {
	          score += DYNAMIC_POINTS;
	        } else if (isSplat(segment)) {
	          score -= SEGMENT_POINTS + SPLAT_PENALTY;
	        } else {
	          score += STATIC_POINTS;
	        }

	        return score;
	      }, 0);

	  return { route, score, index };
	}

	/**
	 * Give a score to all routes and sort them on that
	 * @param {object[]} routes
	 * @return {object[]}
	 */
	function rankRoutes(routes) {
	  return (
	    routes
	      .map(rankRoute)
	      // If two routes have the exact same score, we go by index instead
	      .sort((a, b) =>
	        a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index
	      )
	  );
	}

	/**
	 * Ranks and picks the best route to match. Each segment gets the highest
	 * amount of points, then the type of segment gets an additional amount of
	 * points where
	 *
	 *  static > dynamic > splat > root
	 *
	 * This way we don't have to worry about the order of our routes, let the
	 * computers do it.
	 *
	 * A route looks like this
	 *
	 *  { path, default, value }
	 *
	 * And a returned match looks like:
	 *
	 *  { route, params, uri }
	 *
	 * @param {object[]} routes
	 * @param {string} uri
	 * @return {?object}
	 */
	function pick(routes, uri) {
	  let match;
	  let default_;

	  const [uriPathname] = uri.split("?");
	  const uriSegments = segmentize(uriPathname);
	  const isRootUri = uriSegments[0] === "";
	  const ranked = rankRoutes(routes);

	  for (let i = 0, l = ranked.length; i < l; i++) {
	    const route = ranked[i].route;
	    let missed = false;

	    if (route.default) {
	      default_ = {
	        route,
	        params: {},
	        uri
	      };
	      continue;
	    }

	    const routeSegments = segmentize(route.path);
	    const params = {};
	    const max = Math.max(uriSegments.length, routeSegments.length);
	    let index = 0;

	    for (; index < max; index++) {
	      const routeSegment = routeSegments[index];
	      const uriSegment = uriSegments[index];

	      if (routeSegment !== undefined && isSplat(routeSegment)) {
	        // Hit a splat, just grab the rest, and return a match
	        // uri:   /files/documents/work
	        // route: /files/* or /files/*splatname
	        const splatName = routeSegment === "*" ? "*" : routeSegment.slice(1);

	        params[splatName] = uriSegments
	          .slice(index)
	          .map(decodeURIComponent)
	          .join("/");
	        break;
	      }

	      if (uriSegment === undefined) {
	        // URI is shorter than the route, no match
	        // uri:   /users
	        // route: /users/:userId
	        missed = true;
	        break;
	      }

	      let dynamicMatch = paramRe.exec(routeSegment);

	      if (dynamicMatch && !isRootUri) {
	        const value = decodeURIComponent(uriSegment);
	        params[dynamicMatch[1]] = value;
	      } else if (routeSegment !== uriSegment) {
	        // Current segments don't match, not dynamic, not splat, so no match
	        // uri:   /users/123/settings
	        // route: /users/:id/profile
	        missed = true;
	        break;
	      }
	    }

	    if (!missed) {
	      match = {
	        route,
	        params,
	        uri: "/" + uriSegments.slice(0, index).join("/")
	      };
	      break;
	    }
	  }

	  return match || default_ || null;
	}

	/**
	 * Check if the `path` matches the `uri`.
	 * @param {string} path
	 * @param {string} uri
	 * @return {?object}
	 */
	function match(route, uri) {
	  return pick([route], uri);
	}

	/**
	 * Add the query to the pathname if a query is given
	 * @param {string} pathname
	 * @param {string} [query]
	 * @return {string}
	 */
	function addQuery(pathname, query) {
	  return pathname + (query ? `?${query}` : "");
	}

	/**
	 * Resolve URIs as though every path is a directory, no files. Relative URIs
	 * in the browser can feel awkward because not only can you be "in a directory",
	 * you can be "at a file", too. For example:
	 *
	 *  browserSpecResolve('foo', '/bar/') => /bar/foo
	 *  browserSpecResolve('foo', '/bar') => /foo
	 *
	 * But on the command line of a file system, it's not as complicated. You can't
	 * `cd` from a file, only directories. This way, links have to know less about
	 * their current path. To go deeper you can do this:
	 *
	 *  <Link to="deeper"/>
	 *  // instead of
	 *  <Link to=`{${props.uri}/deeper}`/>
	 *
	 * Just like `cd`, if you want to go deeper from the command line, you do this:
	 *
	 *  cd deeper
	 *  # not
	 *  cd $(pwd)/deeper
	 *
	 * By treating every path as a directory, linking to relative paths should
	 * require less contextual information and (fingers crossed) be more intuitive.
	 * @param {string} to
	 * @param {string} base
	 * @return {string}
	 */
	function resolve(to, base) {
	  // /foo/bar, /baz/qux => /foo/bar
	  if (startsWith(to, "/")) {
	    return to;
	  }

	  const [toPathname, toQuery] = to.split("?");
	  const [basePathname] = base.split("?");
	  const toSegments = segmentize(toPathname);
	  const baseSegments = segmentize(basePathname);

	  // ?a=b, /users?b=c => /users?a=b
	  if (toSegments[0] === "") {
	    return addQuery(basePathname, toQuery);
	  }

	  // profile, /users/789 => /users/789/profile
	  if (!startsWith(toSegments[0], ".")) {
	    const pathname = baseSegments.concat(toSegments).join("/");

	    return addQuery((basePathname === "/" ? "" : "/") + pathname, toQuery);
	  }

	  // ./       , /users/123 => /users/123
	  // ../      , /users/123 => /users
	  // ../..    , /users/123 => /
	  // ../../one, /a/b/c/d   => /a/b/one
	  // .././one , /a/b/c/d   => /a/b/c/one
	  const allSegments = baseSegments.concat(toSegments);
	  const segments = [];

	  allSegments.forEach(segment => {
	    if (segment === "..") {
	      segments.pop();
	    } else if (segment !== ".") {
	      segments.push(segment);
	    }
	  });

	  return addQuery("/" + segments.join("/"), toQuery);
	}

	/**
	 * Combines the `basepath` and the `path` into one path.
	 * @param {string} basepath
	 * @param {string} path
	 */
	function combinePaths(basepath, path) {
	  return `${stripSlashes(
    path === "/" ? basepath : `${stripSlashes(basepath)}/${stripSlashes(path)}`
  )}/`;
	}

	/**
	 * Decides whether a given `event` should result in a navigation or not.
	 * @param {object} event
	 */
	function shouldNavigate(event) {
	  return (
	    !event.defaultPrevented &&
	    event.button === 0 &&
	    !(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)
	  );
	}

	/* node_modules/svelte-routing/src/Router.svelte generated by Svelte v3.30.0 */

	function create_fragment(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[9].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && dirty & /*$$scope*/ 256) {
						update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance($$self, $$props, $$invalidate) {
		let $base;
		let $location;
		let $routes;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots("Router", slots, ['default']);
		let { basepath = "/" } = $$props;
		let { url = null } = $$props;
		const locationContext = getContext(LOCATION);
		const routerContext = getContext(ROUTER);
		const routes = writable([]);
		validate_store(routes, "routes");
		component_subscribe($$self, routes, value => $$invalidate(7, $routes = value));
		const activeRoute = writable(null);
		let hasActiveRoute = false; // Used in SSR to synchronously set that a Route is active.

		// If locationContext is not set, this is the topmost Router in the tree.
		// If the `url` prop is given we force the location to it.
		const location = locationContext || writable(url ? { pathname: url } : globalHistory.location);

		validate_store(location, "location");
		component_subscribe($$self, location, value => $$invalidate(6, $location = value));

		// If routerContext is set, the routerBase of the parent Router
		// will be the base for this Router's descendants.
		// If routerContext is not set, the path and resolved uri will both
		// have the value of the basepath prop.
		const base = routerContext
		? routerContext.routerBase
		: writable({ path: basepath, uri: basepath });

		validate_store(base, "base");
		component_subscribe($$self, base, value => $$invalidate(5, $base = value));

		const routerBase = derived([base, activeRoute], ([base, activeRoute]) => {
			// If there is no activeRoute, the routerBase will be identical to the base.
			if (activeRoute === null) {
				return base;
			}

			const { path: basepath } = base;
			const { route, uri } = activeRoute;

			// Remove the potential /* or /*splatname from
			// the end of the child Routes relative paths.
			const path = route.default
			? basepath
			: route.path.replace(/\*.*$/, "");

			return { path, uri };
		});

		function registerRoute(route) {
			const { path: basepath } = $base;
			let { path } = route;

			// We store the original path in the _path property so we can reuse
			// it when the basepath changes. The only thing that matters is that
			// the route reference is intact, so mutation is fine.
			route._path = path;

			route.path = combinePaths(basepath, path);

			if (typeof window === "undefined") {
				// In SSR we should set the activeRoute immediately if it is a match.
				// If there are more Routes being registered after a match is found,
				// we just skip them.
				if (hasActiveRoute) {
					return;
				}

				const matchingRoute = match(route, $location.pathname);

				if (matchingRoute) {
					activeRoute.set(matchingRoute);
					hasActiveRoute = true;
				}
			} else {
				routes.update(rs => {
					rs.push(route);
					return rs;
				});
			}
		}

		function unregisterRoute(route) {
			routes.update(rs => {
				const index = rs.indexOf(route);
				rs.splice(index, 1);
				return rs;
			});
		}

		if (!locationContext) {
			// The topmost Router in the tree is responsible for updating
			// the location store and supplying it through context.
			onMount(() => {
				const unlisten = globalHistory.listen(history => {
					location.set(history.location);
				});

				return unlisten;
			});

			setContext(LOCATION, location);
		}

		setContext(ROUTER, {
			activeRoute,
			base,
			routerBase,
			registerRoute,
			unregisterRoute
		});

		const writable_props = ["basepath", "url"];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Router> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ("basepath" in $$props) $$invalidate(3, basepath = $$props.basepath);
			if ("url" in $$props) $$invalidate(4, url = $$props.url);
			if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
		};

		$$self.$capture_state = () => ({
			getContext,
			setContext,
			onMount,
			writable,
			derived,
			LOCATION,
			ROUTER,
			globalHistory,
			pick,
			match,
			stripSlashes,
			combinePaths,
			basepath,
			url,
			locationContext,
			routerContext,
			routes,
			activeRoute,
			hasActiveRoute,
			location,
			base,
			routerBase,
			registerRoute,
			unregisterRoute,
			$base,
			$location,
			$routes
		});

		$$self.$inject_state = $$props => {
			if ("basepath" in $$props) $$invalidate(3, basepath = $$props.basepath);
			if ("url" in $$props) $$invalidate(4, url = $$props.url);
			if ("hasActiveRoute" in $$props) hasActiveRoute = $$props.hasActiveRoute;
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*$base*/ 32) {
				// This reactive statement will update all the Routes' path when
				// the basepath changes.
				 {
					const { path: basepath } = $base;

					routes.update(rs => {
						rs.forEach(r => r.path = combinePaths(basepath, r._path));
						return rs;
					});
				}
			}

			if ($$self.$$.dirty & /*$routes, $location*/ 192) {
				// This reactive statement will be run when the Router is created
				// when there are no Routes and then again the following tick, so it
				// will not find an active Route in SSR and in the browser it will only
				// pick an active Route after all Routes have been registered.
				 {
					const bestMatch = pick($routes, $location.pathname);
					activeRoute.set(bestMatch);
				}
			}
		};

		return [
			routes,
			location,
			base,
			basepath,
			url,
			$base,
			$location,
			$routes,
			$$scope,
			slots
		];
	}

	class Router extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance, create_fragment, safe_not_equal, { basepath: 3, url: 4 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Router",
				options,
				id: create_fragment.name
			});
		}

		get basepath() {
			throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set basepath(value) {
			throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get url() {
			throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set url(value) {
			throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* node_modules/svelte-routing/src/Route.svelte generated by Svelte v3.30.0 */

	const get_default_slot_changes = dirty => ({
		params: dirty & /*routeParams*/ 4,
		location: dirty & /*$location*/ 16
	});

	const get_default_slot_context = ctx => ({
		params: /*routeParams*/ ctx[2],
		location: /*$location*/ ctx[4]
	});

	// (40:0) {#if $activeRoute !== null && $activeRoute.route === route}
	function create_if_block(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_1, create_else_block];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*component*/ ctx[0] !== null) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				if_block.c();
				if_block_anchor = empty();
			},
			m: function mount(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if_blocks[current_block_type_index].d(detaching);
				if (detaching) detach_dev(if_block_anchor);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block.name,
			type: "if",
			source: "(40:0) {#if $activeRoute !== null && $activeRoute.route === route}",
			ctx
		});

		return block;
	}

	// (43:2) {:else}
	function create_else_block(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[10].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], get_default_slot_context);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && dirty & /*$$scope, routeParams, $location*/ 532) {
						update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, get_default_slot_changes, get_default_slot_context);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block.name,
			type: "else",
			source: "(43:2) {:else}",
			ctx
		});

		return block;
	}

	// (41:2) {#if component !== null}
	function create_if_block_1(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;

		const switch_instance_spread_levels = [
			{ location: /*$location*/ ctx[4] },
			/*routeParams*/ ctx[2],
			/*routeProps*/ ctx[3]
		];

		var switch_value = /*component*/ ctx[0];

		function switch_props(ctx) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			return {
				props: switch_instance_props,
				$$inline: true
			};
		}

		if (switch_value) {
			switch_instance = new switch_value(switch_props());
		}

		const block = {
			c: function create() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m: function mount(target, anchor) {
				if (switch_instance) {
					mount_component(switch_instance, target, anchor);
				}

				insert_dev(target, switch_instance_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const switch_instance_changes = (dirty & /*$location, routeParams, routeProps*/ 28)
				? get_spread_update(switch_instance_spread_levels, [
						dirty & /*$location*/ 16 && { location: /*$location*/ ctx[4] },
						dirty & /*routeParams*/ 4 && get_spread_object(/*routeParams*/ ctx[2]),
						dirty & /*routeProps*/ 8 && get_spread_object(/*routeProps*/ ctx[3])
					])
				: {};

				if (switch_value !== (switch_value = /*component*/ ctx[0])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = new switch_value(switch_props());
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					switch_instance.$set(switch_instance_changes);
				}
			},
			i: function intro(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) detach_dev(switch_instance_anchor);
				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1.name,
			type: "if",
			source: "(41:2) {#if component !== null}",
			ctx
		});

		return block;
	}

	function create_fragment$1(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*$activeRoute*/ ctx[1] !== null && /*$activeRoute*/ ctx[1].route === /*route*/ ctx[7] && create_if_block(ctx);

		const block = {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (/*$activeRoute*/ ctx[1] !== null && /*$activeRoute*/ ctx[1].route === /*route*/ ctx[7]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*$activeRoute*/ 2) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (if_block) if_block.d(detaching);
				if (detaching) detach_dev(if_block_anchor);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1($$self, $$props, $$invalidate) {
		let $activeRoute;
		let $location;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots("Route", slots, ['default']);
		let { path = "" } = $$props;
		let { component = null } = $$props;
		const { registerRoute, unregisterRoute, activeRoute } = getContext(ROUTER);
		validate_store(activeRoute, "activeRoute");
		component_subscribe($$self, activeRoute, value => $$invalidate(1, $activeRoute = value));
		const location = getContext(LOCATION);
		validate_store(location, "location");
		component_subscribe($$self, location, value => $$invalidate(4, $location = value));

		const route = {
			path,
			// If no path prop is given, this Route will act as the default Route
			// that is rendered if no other Route in the Router is a match.
			default: path === ""
		};

		let routeParams = {};
		let routeProps = {};
		registerRoute(route);

		// There is no need to unregister Routes in SSR since it will all be
		// thrown away anyway.
		if (typeof window !== "undefined") {
			onDestroy(() => {
				unregisterRoute(route);
			});
		}

		$$self.$$set = $$new_props => {
			$$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
			if ("path" in $$new_props) $$invalidate(8, path = $$new_props.path);
			if ("component" in $$new_props) $$invalidate(0, component = $$new_props.component);
			if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({
			getContext,
			onDestroy,
			ROUTER,
			LOCATION,
			path,
			component,
			registerRoute,
			unregisterRoute,
			activeRoute,
			location,
			route,
			routeParams,
			routeProps,
			$activeRoute,
			$location
		});

		$$self.$inject_state = $$new_props => {
			$$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
			if ("path" in $$props) $$invalidate(8, path = $$new_props.path);
			if ("component" in $$props) $$invalidate(0, component = $$new_props.component);
			if ("routeParams" in $$props) $$invalidate(2, routeParams = $$new_props.routeParams);
			if ("routeProps" in $$props) $$invalidate(3, routeProps = $$new_props.routeProps);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*$activeRoute*/ 2) {
				 if ($activeRoute && $activeRoute.route === route) {
					$$invalidate(2, routeParams = $activeRoute.params);
				}
			}

			 {
				const { path, component, ...rest } = $$props;
				$$invalidate(3, routeProps = rest);
			}
		};

		$$props = exclude_internal_props($$props);

		return [
			component,
			$activeRoute,
			routeParams,
			routeProps,
			$location,
			activeRoute,
			location,
			route,
			path,
			$$scope,
			slots
		];
	}

	class Route extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1, create_fragment$1, safe_not_equal, { path: 8, component: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Route",
				options,
				id: create_fragment$1.name
			});
		}

		get path() {
			throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set path(value) {
			throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get component() {
			throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set component(value) {
			throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* node_modules/svelte-routing/src/Link.svelte generated by Svelte v3.30.0 */
	const file = "node_modules/svelte-routing/src/Link.svelte";

	function create_fragment$2(ctx) {
		let a;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[15].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

		let a_levels = [
			{ href: /*href*/ ctx[0] },
			{ "aria-current": /*ariaCurrent*/ ctx[2] },
			/*props*/ ctx[1]
		];

		let a_data = {};

		for (let i = 0; i < a_levels.length; i += 1) {
			a_data = assign(a_data, a_levels[i]);
		}

		const block = {
			c: function create() {
				a = element("a");
				if (default_slot) default_slot.c();
				set_attributes(a, a_data);
				add_location(a, file, 40, 0, 1249);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, a, anchor);

				if (default_slot) {
					default_slot.m(a, null);
				}

				current = true;

				if (!mounted) {
					dispose = listen_dev(a, "click", /*onClick*/ ctx[5], false, false, false);
					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && dirty & /*$$scope*/ 16384) {
						update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[14], dirty, null, null);
					}
				}

				set_attributes(a, a_data = get_spread_update(a_levels, [
					(!current || dirty & /*href*/ 1) && { href: /*href*/ ctx[0] },
					(!current || dirty & /*ariaCurrent*/ 4) && { "aria-current": /*ariaCurrent*/ ctx[2] },
					dirty & /*props*/ 2 && /*props*/ ctx[1]
				]));
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) detach_dev(a);
				if (default_slot) default_slot.d(detaching);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$2.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$2($$self, $$props, $$invalidate) {
		let $base;
		let $location;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots("Link", slots, ['default']);
		let { to = "#" } = $$props;
		let { replace = false } = $$props;
		let { state = {} } = $$props;
		let { getProps = () => ({}) } = $$props;
		const { base } = getContext(ROUTER);
		validate_store(base, "base");
		component_subscribe($$self, base, value => $$invalidate(12, $base = value));
		const location = getContext(LOCATION);
		validate_store(location, "location");
		component_subscribe($$self, location, value => $$invalidate(13, $location = value));
		const dispatch = createEventDispatcher();
		let href, isPartiallyCurrent, isCurrent, props;

		function onClick(event) {
			dispatch("click", event);

			if (shouldNavigate(event)) {
				event.preventDefault();

				// Don't push another entry to the history stack when the user
				// clicks on a Link to the page they are currently on.
				const shouldReplace = $location.pathname === href || replace;

				navigate(href, { state, replace: shouldReplace });
			}
		}

		const writable_props = ["to", "replace", "state", "getProps"];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Link> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ("to" in $$props) $$invalidate(6, to = $$props.to);
			if ("replace" in $$props) $$invalidate(7, replace = $$props.replace);
			if ("state" in $$props) $$invalidate(8, state = $$props.state);
			if ("getProps" in $$props) $$invalidate(9, getProps = $$props.getProps);
			if ("$$scope" in $$props) $$invalidate(14, $$scope = $$props.$$scope);
		};

		$$self.$capture_state = () => ({
			getContext,
			createEventDispatcher,
			ROUTER,
			LOCATION,
			navigate,
			startsWith,
			resolve,
			shouldNavigate,
			to,
			replace,
			state,
			getProps,
			base,
			location,
			dispatch,
			href,
			isPartiallyCurrent,
			isCurrent,
			props,
			onClick,
			$base,
			$location,
			ariaCurrent
		});

		$$self.$inject_state = $$props => {
			if ("to" in $$props) $$invalidate(6, to = $$props.to);
			if ("replace" in $$props) $$invalidate(7, replace = $$props.replace);
			if ("state" in $$props) $$invalidate(8, state = $$props.state);
			if ("getProps" in $$props) $$invalidate(9, getProps = $$props.getProps);
			if ("href" in $$props) $$invalidate(0, href = $$props.href);
			if ("isPartiallyCurrent" in $$props) $$invalidate(10, isPartiallyCurrent = $$props.isPartiallyCurrent);
			if ("isCurrent" in $$props) $$invalidate(11, isCurrent = $$props.isCurrent);
			if ("props" in $$props) $$invalidate(1, props = $$props.props);
			if ("ariaCurrent" in $$props) $$invalidate(2, ariaCurrent = $$props.ariaCurrent);
		};

		let ariaCurrent;

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*to, $base*/ 4160) {
				 $$invalidate(0, href = to === "/" ? $base.uri : resolve(to, $base.uri));
			}

			if ($$self.$$.dirty & /*$location, href*/ 8193) {
				 $$invalidate(10, isPartiallyCurrent = startsWith($location.pathname, href));
			}

			if ($$self.$$.dirty & /*href, $location*/ 8193) {
				 $$invalidate(11, isCurrent = href === $location.pathname);
			}

			if ($$self.$$.dirty & /*isCurrent*/ 2048) {
				 $$invalidate(2, ariaCurrent = isCurrent ? "page" : undefined);
			}

			if ($$self.$$.dirty & /*getProps, $location, href, isPartiallyCurrent, isCurrent*/ 11777) {
				 $$invalidate(1, props = getProps({
					location: $location,
					href,
					isPartiallyCurrent,
					isCurrent
				}));
			}
		};

		return [
			href,
			props,
			ariaCurrent,
			base,
			location,
			onClick,
			to,
			replace,
			state,
			getProps,
			isPartiallyCurrent,
			isCurrent,
			$base,
			$location,
			$$scope,
			slots
		];
	}

	class Link extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$2, create_fragment$2, safe_not_equal, { to: 6, replace: 7, state: 8, getProps: 9 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Link",
				options,
				id: create_fragment$2.name
			});
		}

		get to() {
			throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set to(value) {
			throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get replace() {
			throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set replace(value) {
			throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get state() {
			throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set state(value) {
			throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get getProps() {
			throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set getProps(value) {
			throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	function num( i, l ){
	    let n = `00${l-i}`;
	    return n.substr(-2);
	}

	function getProject( projects, url ){
	    let project;
	    for (let i = 0; i < projects.length; i++) {
	        if( projects[i].url === url ){
	            project = projects[i];
	            project['n'] = num(i,projects.length);
	            break;
	        }
	    }
	    return project;
	}

	/* src/routes/Index.svelte generated by Svelte v3.30.0 */
	const file$1 = "src/routes/Index.svelte";

	function get_each_context(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[1] = list[i];
		child_ctx[3] = i;
		return child_ctx;
	}

	// (25:28) {#if project.hasOwnProperty('subtitle')}
	function create_if_block$1(ctx) {
		let span;
		let t0_value = /*project*/ ctx[1].subtitle + "";
		let t0;
		let t1;

		const block = {
			c: function create() {
				span = element("span");
				t0 = text(t0_value);
				t1 = text(",");
				add_location(span, file$1, 25, 32, 570);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				append_dev(span, t0);
				insert_dev(target, t1, anchor);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*data*/ 1 && t0_value !== (t0_value = /*project*/ ctx[1].subtitle + "")) set_data_dev(t0, t0_value);
			},
			d: function destroy(detaching) {
				if (detaching) detach_dev(span);
				if (detaching) detach_dev(t1);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$1.name,
			type: "if",
			source: "(25:28) {#if project.hasOwnProperty('subtitle')}",
			ctx
		});

		return block;
	}

	// (19:16) <Link to={project.url}>
	function create_default_slot_1(ctx) {
		let article;
		let span0;
		let t0_value = num(/*i*/ ctx[3], /*data*/ ctx[0].pages.length) + "";
		let t0;
		let h2;
		let t1_value = /*project*/ ctx[1].title + "";
		let t1;
		let t2;
		let p;
		let show_if = /*project*/ ctx[1].hasOwnProperty("subtitle");
		let t3;
		let span1;
		let t4_value = /*project*/ ctx[1].year + "";
		let t4;
		let if_block = show_if && create_if_block$1(ctx);

		const block = {
			c: function create() {
				article = element("article");
				span0 = element("span");
				t0 = text(t0_value);
				h2 = element("h2");
				t1 = text(t1_value);
				t2 = space();
				p = element("p");
				if (if_block) if_block.c();
				t3 = space();
				span1 = element("span");
				t4 = text(t4_value);
				attr_dev(span0, "class", "i num svelte-1looaik");
				add_location(span0, file$1, 21, 24, 361);
				attr_dev(h2, "class", "svelte-1looaik");
				add_location(h2, file$1, 21, 78, 415);
				attr_dev(span1, "class", "year");
				add_location(span1, file$1, 27, 28, 665);
				add_location(p, file$1, 23, 24, 465);
				attr_dev(article, "class", "svelte-1looaik");
				add_location(article, file$1, 19, 20, 326);
			},
			m: function mount(target, anchor) {
				insert_dev(target, article, anchor);
				append_dev(article, span0);
				append_dev(span0, t0);
				append_dev(article, h2);
				append_dev(h2, t1);
				append_dev(article, t2);
				append_dev(article, p);
				if (if_block) if_block.m(p, null);
				append_dev(p, t3);
				append_dev(p, span1);
				append_dev(span1, t4);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*data*/ 1 && t0_value !== (t0_value = num(/*i*/ ctx[3], /*data*/ ctx[0].pages.length) + "")) set_data_dev(t0, t0_value);
				if (dirty & /*data*/ 1 && t1_value !== (t1_value = /*project*/ ctx[1].title + "")) set_data_dev(t1, t1_value);
				if (dirty & /*data*/ 1) show_if = /*project*/ ctx[1].hasOwnProperty("subtitle");

				if (show_if) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$1(ctx);
						if_block.c();
						if_block.m(p, t3);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (dirty & /*data*/ 1 && t4_value !== (t4_value = /*project*/ ctx[1].year + "")) set_data_dev(t4, t4_value);
			},
			d: function destroy(detaching) {
				if (detaching) detach_dev(article);
				if (if_block) if_block.d();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_1.name,
			type: "slot",
			source: "(19:16) <Link to={project.url}>",
			ctx
		});

		return block;
	}

	// (17:8) {#each data.pages as project, i}
	function create_each_block(ctx) {
		let li;
		let link;
		let t;
		let current;

		link = new Link({
				props: {
					to: /*project*/ ctx[1].url,
					$$slots: { default: [create_default_slot_1] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				li = element("li");
				create_component(link.$$.fragment);
				t = space();
				attr_dev(li, "class", "svelte-1looaik");
				add_location(li, file$1, 17, 12, 261);
			},
			m: function mount(target, anchor) {
				insert_dev(target, li, anchor);
				mount_component(link, li, null);
				append_dev(li, t);
				current = true;
			},
			p: function update(ctx, dirty) {
				const link_changes = {};
				if (dirty & /*data*/ 1) link_changes.to = /*project*/ ctx[1].url;

				if (dirty & /*$$scope, data*/ 17) {
					link_changes.$$scope = { dirty, ctx };
				}

				link.$set(link_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(link.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(link.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) detach_dev(li);
				destroy_component(link);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block.name,
			type: "each",
			source: "(17:8) {#each data.pages as project, i}",
			ctx
		});

		return block;
	}

	// (41:4) <Link to="impressum">
	function create_default_slot(ctx) {
		let t;

		const block = {
			c: function create() {
				t = text("Impressum");
			},
			m: function mount(target, anchor) {
				insert_dev(target, t, anchor);
			},
			d: function destroy(detaching) {
				if (detaching) detach_dev(t);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot.name,
			type: "slot",
			source: "(41:4) <Link to=\\\"impressum\\\">",
			ctx
		});

		return block;
	}

	function create_fragment$3(ctx) {
		let main;
		let header;
		let raw0_value = /*data*/ ctx[0].header + "";
		let t0;
		let ol;
		let t1;
		let footer;
		let raw1_value = /*data*/ ctx[0].footer + "";
		let t2;
		let link;
		let current;
		let each_value = /*data*/ ctx[0].pages;
		validate_each_argument(each_value);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		link = new Link({
				props: {
					to: "impressum",
					$$slots: { default: [create_default_slot] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				main = element("main");
				header = element("header");
				t0 = space();
				ol = element("ol");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t1 = space();
				footer = element("footer");
				t2 = space();
				create_component(link.$$.fragment);
				add_location(header, file$1, 11, 4, 147);
				attr_dev(ol, "class", "svelte-1looaik");
				add_location(ol, file$1, 15, 4, 203);
				add_location(footer, file$1, 36, 4, 840);
				attr_dev(main, "class", "svelte-1looaik");
				add_location(main, file$1, 9, 0, 135);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, main, anchor);
				append_dev(main, header);
				header.innerHTML = raw0_value;
				append_dev(main, t0);
				append_dev(main, ol);

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(ol, null);
				}

				append_dev(main, t1);
				append_dev(main, footer);
				footer.innerHTML = raw1_value;
				append_dev(main, t2);
				mount_component(link, main, null);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				if ((!current || dirty & /*data*/ 1) && raw0_value !== (raw0_value = /*data*/ ctx[0].header + "")) header.innerHTML = raw0_value;
				if (dirty & /*data, num*/ 1) {
					each_value = /*data*/ ctx[0].pages;
					validate_each_argument(each_value);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(ol, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if ((!current || dirty & /*data*/ 1) && raw1_value !== (raw1_value = /*data*/ ctx[0].footer + "")) footer.innerHTML = raw1_value;			const link_changes = {};

				if (dirty & /*$$scope*/ 16) {
					link_changes.$$scope = { dirty, ctx };
				}

				link.$set(link_changes);
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				transition_in(link.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				transition_out(link.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) detach_dev(main);
				destroy_each(each_blocks, detaching);
				destroy_component(link);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$3.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$3($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots("Index", slots, []);
		let { data } = $$props;
		const writable_props = ["data"];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Index> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ("data" in $$props) $$invalidate(0, data = $$props.data);
		};

		$$self.$capture_state = () => ({ Link, num, data });

		$$self.$inject_state = $$props => {
			if ("data" in $$props) $$invalidate(0, data = $$props.data);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [data];
	}

	class Index extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$3, create_fragment$3, safe_not_equal, { data: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Index",
				options,
				id: create_fragment$3.name
			});

			const { ctx } = this.$$;
			const props = options.props || {};

			if (/*data*/ ctx[0] === undefined && !("data" in props)) {
				console.warn("<Index> was created without expected prop 'data'");
			}
		}

		get data() {
			throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set data(value) {
			throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/components/Img.svelte generated by Svelte v3.30.0 */

	const file$2 = "src/components/Img.svelte";

	function create_fragment$4(ctx) {
		let img;
		let img_data_srcset_value;

		const block = {
			c: function create() {
				img = element("img");
				attr_dev(img, "alt", /*alt*/ ctx[2]);
				attr_dev(img, "data-sizes", "auto");
				attr_dev(img, "class", "lazyload");
				attr_dev(img, "data-src", /*src*/ ctx[1]);
				attr_dev(img, "data-srcset", img_data_srcset_value = set(/*srcset*/ ctx[0]));
				add_location(img, file$2, 16, 0, 278);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, img, anchor);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*alt*/ 4) {
					attr_dev(img, "alt", /*alt*/ ctx[2]);
				}

				if (dirty & /*src*/ 2) {
					attr_dev(img, "data-src", /*src*/ ctx[1]);
				}

				if (dirty & /*srcset*/ 1 && img_data_srcset_value !== (img_data_srcset_value = set(/*srcset*/ ctx[0]))) {
					attr_dev(img, "data-srcset", img_data_srcset_value);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) detach_dev(img);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$4.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function set(srcset) {
		let r = "";

		for (const size of srcset) {
			r += `${size.src} ${size.width}w, `;
		}

		return r;
	}

	function instance$4($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots("Img", slots, []);
		let { srcset = [] } = $$props;
		let { src = srcset[0].url } = $$props;
		let { alt = "" } = $$props;
		const writable_props = ["srcset", "src", "alt"];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Img> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ("srcset" in $$props) $$invalidate(0, srcset = $$props.srcset);
			if ("src" in $$props) $$invalidate(1, src = $$props.src);
			if ("alt" in $$props) $$invalidate(2, alt = $$props.alt);
		};

		$$self.$capture_state = () => ({ srcset, src, alt, set });

		$$self.$inject_state = $$props => {
			if ("srcset" in $$props) $$invalidate(0, srcset = $$props.srcset);
			if ("src" in $$props) $$invalidate(1, src = $$props.src);
			if ("alt" in $$props) $$invalidate(2, alt = $$props.alt);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [srcset, src, alt];
	}

	class Img extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$4, create_fragment$4, safe_not_equal, { srcset: 0, src: 1, alt: 2 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Img",
				options,
				id: create_fragment$4.name
			});
		}

		get srcset() {
			throw new Error("<Img>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set srcset(value) {
			throw new Error("<Img>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get src() {
			throw new Error("<Img>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set src(value) {
			throw new Error("<Img>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get alt() {
			throw new Error("<Img>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set alt(value) {
			throw new Error("<Img>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/**
	 * SSR Window 3.0.0
	 * Better handling for window object in SSR environment
	 * https://github.com/nolimits4web/ssr-window
	 *
	 * Copyright 2020, Vladimir Kharlampidi
	 *
	 * Licensed under MIT
	 *
	 * Released on: November 9, 2020
	 */
	/* eslint-disable no-param-reassign */
	function isObject(obj) {
	    return (obj !== null &&
	        typeof obj === 'object' &&
	        'constructor' in obj &&
	        obj.constructor === Object);
	}
	function extend(target, src) {
	    if (target === void 0) { target = {}; }
	    if (src === void 0) { src = {}; }
	    Object.keys(src).forEach(function (key) {
	        if (typeof target[key] === 'undefined')
	            target[key] = src[key];
	        else if (isObject(src[key]) &&
	            isObject(target[key]) &&
	            Object.keys(src[key]).length > 0) {
	            extend(target[key], src[key]);
	        }
	    });
	}

	var ssrDocument = {
	    body: {},
	    addEventListener: function () { },
	    removeEventListener: function () { },
	    activeElement: {
	        blur: function () { },
	        nodeName: '',
	    },
	    querySelector: function () {
	        return null;
	    },
	    querySelectorAll: function () {
	        return [];
	    },
	    getElementById: function () {
	        return null;
	    },
	    createEvent: function () {
	        return {
	            initEvent: function () { },
	        };
	    },
	    createElement: function () {
	        return {
	            children: [],
	            childNodes: [],
	            style: {},
	            setAttribute: function () { },
	            getElementsByTagName: function () {
	                return [];
	            },
	        };
	    },
	    createElementNS: function () {
	        return {};
	    },
	    importNode: function () {
	        return null;
	    },
	    location: {
	        hash: '',
	        host: '',
	        hostname: '',
	        href: '',
	        origin: '',
	        pathname: '',
	        protocol: '',
	        search: '',
	    },
	};
	function getDocument() {
	    var doc = typeof document !== 'undefined' ? document : {};
	    extend(doc, ssrDocument);
	    return doc;
	}

	var ssrWindow = {
	    document: ssrDocument,
	    navigator: {
	        userAgent: '',
	    },
	    location: {
	        hash: '',
	        host: '',
	        hostname: '',
	        href: '',
	        origin: '',
	        pathname: '',
	        protocol: '',
	        search: '',
	    },
	    history: {
	        replaceState: function () { },
	        pushState: function () { },
	        go: function () { },
	        back: function () { },
	    },
	    CustomEvent: function CustomEvent() {
	        return this;
	    },
	    addEventListener: function () { },
	    removeEventListener: function () { },
	    getComputedStyle: function () {
	        return {
	            getPropertyValue: function () {
	                return '';
	            },
	        };
	    },
	    Image: function () { },
	    Date: function () { },
	    screen: {},
	    setTimeout: function () { },
	    clearTimeout: function () { },
	    matchMedia: function () {
	        return {};
	    },
	    requestAnimationFrame: function (callback) {
	        if (typeof setTimeout === 'undefined') {
	            callback();
	            return null;
	        }
	        return setTimeout(callback, 0);
	    },
	    cancelAnimationFrame: function (id) {
	        if (typeof setTimeout === 'undefined') {
	            return;
	        }
	        clearTimeout(id);
	    },
	};
	function getWindow() {
	    var win = typeof window !== 'undefined' ? window : {};
	    extend(win, ssrWindow);
	    return win;
	}

	/**
	 * Dom7 3.0.0
	 * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
	 * https://framework7.io/docs/dom7.html
	 *
	 * Copyright 2020, Vladimir Kharlampidi
	 *
	 * Licensed under MIT
	 *
	 * Released on: November 9, 2020
	 */

	function _inheritsLoose(subClass, superClass) {
	  subClass.prototype = Object.create(superClass.prototype);
	  subClass.prototype.constructor = subClass;
	  subClass.__proto__ = superClass;
	}

	function _getPrototypeOf(o) {
	  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
	    return o.__proto__ || Object.getPrototypeOf(o);
	  };
	  return _getPrototypeOf(o);
	}

	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	function _isNativeReflectConstruct() {
	  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	  if (Reflect.construct.sham) return false;
	  if (typeof Proxy === "function") return true;

	  try {
	    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	function _construct(Parent, args, Class) {
	  if (_isNativeReflectConstruct()) {
	    _construct = Reflect.construct;
	  } else {
	    _construct = function _construct(Parent, args, Class) {
	      var a = [null];
	      a.push.apply(a, args);
	      var Constructor = Function.bind.apply(Parent, a);
	      var instance = new Constructor();
	      if (Class) _setPrototypeOf(instance, Class.prototype);
	      return instance;
	    };
	  }

	  return _construct.apply(null, arguments);
	}

	function _isNativeFunction(fn) {
	  return Function.toString.call(fn).indexOf("[native code]") !== -1;
	}

	function _wrapNativeSuper(Class) {
	  var _cache = typeof Map === "function" ? new Map() : undefined;

	  _wrapNativeSuper = function _wrapNativeSuper(Class) {
	    if (Class === null || !_isNativeFunction(Class)) return Class;

	    if (typeof Class !== "function") {
	      throw new TypeError("Super expression must either be null or a function");
	    }

	    if (typeof _cache !== "undefined") {
	      if (_cache.has(Class)) return _cache.get(Class);

	      _cache.set(Class, Wrapper);
	    }

	    function Wrapper() {
	      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
	    }

	    Wrapper.prototype = Object.create(Class.prototype, {
	      constructor: {
	        value: Wrapper,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    return _setPrototypeOf(Wrapper, Class);
	  };

	  return _wrapNativeSuper(Class);
	}

	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	/* eslint-disable no-proto */
	function makeReactive(obj) {
	  var proto = obj.__proto__;
	  Object.defineProperty(obj, '__proto__', {
	    get: function get() {
	      return proto;
	    },
	    set: function set(value) {
	      proto.__proto__ = value;
	    }
	  });
	}

	var Dom7 = /*#__PURE__*/function (_Array) {
	  _inheritsLoose(Dom7, _Array);

	  function Dom7(items) {
	    var _this;

	    _this = _Array.call.apply(_Array, [this].concat(items)) || this;
	    makeReactive(_assertThisInitialized(_this));
	    return _this;
	  }

	  return Dom7;
	}( /*#__PURE__*/_wrapNativeSuper(Array));

	function arrayFlat(arr) {
	  if (arr === void 0) {
	    arr = [];
	  }

	  var res = [];
	  arr.forEach(function (el) {
	    if (Array.isArray(el)) {
	      res.push.apply(res, arrayFlat(el));
	    } else {
	      res.push(el);
	    }
	  });
	  return res;
	}
	function arrayFilter(arr, callback) {
	  return Array.prototype.filter.call(arr, callback);
	}
	function arrayUnique(arr) {
	  var uniqueArray = [];

	  for (var i = 0; i < arr.length; i += 1) {
	    if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
	  }

	  return uniqueArray;
	}

	function qsa(selector, context) {
	  if (typeof selector !== 'string') {
	    return [selector];
	  }

	  var a = [];
	  var res = context.querySelectorAll(selector);

	  for (var i = 0; i < res.length; i += 1) {
	    a.push(res[i]);
	  }

	  return a;
	}

	function $(selector, context) {
	  var window = getWindow();
	  var document = getDocument();
	  var arr = [];

	  if (!context && selector instanceof Dom7) {
	    return selector;
	  }

	  if (!selector) {
	    return new Dom7(arr);
	  }

	  if (typeof selector === 'string') {
	    var html = selector.trim();

	    if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
	      var toCreate = 'div';
	      if (html.indexOf('<li') === 0) toCreate = 'ul';
	      if (html.indexOf('<tr') === 0) toCreate = 'tbody';
	      if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
	      if (html.indexOf('<tbody') === 0) toCreate = 'table';
	      if (html.indexOf('<option') === 0) toCreate = 'select';
	      var tempParent = document.createElement(toCreate);
	      tempParent.innerHTML = html;

	      for (var i = 0; i < tempParent.childNodes.length; i += 1) {
	        arr.push(tempParent.childNodes[i]);
	      }
	    } else {
	      arr = qsa(selector.trim(), context || document);
	    } // arr = qsa(selector, document);

	  } else if (selector.nodeType || selector === window || selector === document) {
	    arr.push(selector);
	  } else if (Array.isArray(selector)) {
	    if (selector instanceof Dom7) return selector;
	    arr = selector;
	  }

	  return new Dom7(arrayUnique(arr));
	}

	$.fn = Dom7.prototype;

	function addClass() {
	  for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {
	    classes[_key] = arguments[_key];
	  }

	  var classNames = arrayFlat(classes.map(function (c) {
	    return c.split(' ');
	  }));
	  this.forEach(function (el) {
	    var _el$classList;

	    (_el$classList = el.classList).add.apply(_el$classList, classNames);
	  });
	  return this;
	}

	function removeClass() {
	  for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	    classes[_key2] = arguments[_key2];
	  }

	  var classNames = arrayFlat(classes.map(function (c) {
	    return c.split(' ');
	  }));
	  this.forEach(function (el) {
	    var _el$classList2;

	    (_el$classList2 = el.classList).remove.apply(_el$classList2, classNames);
	  });
	  return this;
	}

	function toggleClass() {
	  for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	    classes[_key3] = arguments[_key3];
	  }

	  var classNames = arrayFlat(classes.map(function (c) {
	    return c.split(' ');
	  }));
	  this.forEach(function (el) {
	    classNames.forEach(function (className) {
	      el.classList.toggle(className);
	    });
	  });
	}

	function hasClass() {
	  for (var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	    classes[_key4] = arguments[_key4];
	  }

	  var classNames = arrayFlat(classes.map(function (c) {
	    return c.split(' ');
	  }));
	  return arrayFilter(this, function (el) {
	    return classNames.filter(function (className) {
	      return el.classList.contains(className);
	    }).length > 0;
	  }).length > 0;
	}

	function attr$1(attrs, value) {
	  if (arguments.length === 1 && typeof attrs === 'string') {
	    // Get attr
	    if (this[0]) return this[0].getAttribute(attrs);
	    return undefined;
	  } // Set attrs


	  for (var i = 0; i < this.length; i += 1) {
	    if (arguments.length === 2) {
	      // String
	      this[i].setAttribute(attrs, value);
	    } else {
	      // Object
	      for (var attrName in attrs) {
	        this[i][attrName] = attrs[attrName];
	        this[i].setAttribute(attrName, attrs[attrName]);
	      }
	    }
	  }

	  return this;
	}

	function removeAttr(attr) {
	  for (var i = 0; i < this.length; i += 1) {
	    this[i].removeAttribute(attr);
	  }

	  return this;
	}

	function transform(transform) {
	  for (var i = 0; i < this.length; i += 1) {
	    this[i].style.transform = transform;
	  }

	  return this;
	}

	function transition(duration) {
	  for (var i = 0; i < this.length; i += 1) {
	    this[i].style.transitionDuration = typeof duration !== 'string' ? duration + "ms" : duration;
	  }

	  return this;
	}

	function on() {
	  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
	    args[_key5] = arguments[_key5];
	  }

	  var eventType = args[0],
	      targetSelector = args[1],
	      listener = args[2],
	      capture = args[3];

	  if (typeof args[1] === 'function') {
	    eventType = args[0];
	    listener = args[1];
	    capture = args[2];
	    targetSelector = undefined;
	  }

	  if (!capture) capture = false;

	  function handleLiveEvent(e) {
	    var target = e.target;
	    if (!target) return;
	    var eventData = e.target.dom7EventData || [];

	    if (eventData.indexOf(e) < 0) {
	      eventData.unshift(e);
	    }

	    if ($(target).is(targetSelector)) listener.apply(target, eventData);else {
	      var _parents = $(target).parents(); // eslint-disable-line


	      for (var k = 0; k < _parents.length; k += 1) {
	        if ($(_parents[k]).is(targetSelector)) listener.apply(_parents[k], eventData);
	      }
	    }
	  }

	  function handleEvent(e) {
	    var eventData = e && e.target ? e.target.dom7EventData || [] : [];

	    if (eventData.indexOf(e) < 0) {
	      eventData.unshift(e);
	    }

	    listener.apply(this, eventData);
	  }

	  var events = eventType.split(' ');
	  var j;

	  for (var i = 0; i < this.length; i += 1) {
	    var el = this[i];

	    if (!targetSelector) {
	      for (j = 0; j < events.length; j += 1) {
	        var event = events[j];
	        if (!el.dom7Listeners) el.dom7Listeners = {};
	        if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
	        el.dom7Listeners[event].push({
	          listener: listener,
	          proxyListener: handleEvent
	        });
	        el.addEventListener(event, handleEvent, capture);
	      }
	    } else {
	      // Live events
	      for (j = 0; j < events.length; j += 1) {
	        var _event = events[j];
	        if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
	        if (!el.dom7LiveListeners[_event]) el.dom7LiveListeners[_event] = [];

	        el.dom7LiveListeners[_event].push({
	          listener: listener,
	          proxyListener: handleLiveEvent
	        });

	        el.addEventListener(_event, handleLiveEvent, capture);
	      }
	    }
	  }

	  return this;
	}

	function off() {
	  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
	    args[_key6] = arguments[_key6];
	  }

	  var eventType = args[0],
	      targetSelector = args[1],
	      listener = args[2],
	      capture = args[3];

	  if (typeof args[1] === 'function') {
	    eventType = args[0];
	    listener = args[1];
	    capture = args[2];
	    targetSelector = undefined;
	  }

	  if (!capture) capture = false;
	  var events = eventType.split(' ');

	  for (var i = 0; i < events.length; i += 1) {
	    var event = events[i];

	    for (var j = 0; j < this.length; j += 1) {
	      var el = this[j];
	      var handlers = void 0;

	      if (!targetSelector && el.dom7Listeners) {
	        handlers = el.dom7Listeners[event];
	      } else if (targetSelector && el.dom7LiveListeners) {
	        handlers = el.dom7LiveListeners[event];
	      }

	      if (handlers && handlers.length) {
	        for (var k = handlers.length - 1; k >= 0; k -= 1) {
	          var handler = handlers[k];

	          if (listener && handler.listener === listener) {
	            el.removeEventListener(event, handler.proxyListener, capture);
	            handlers.splice(k, 1);
	          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
	            el.removeEventListener(event, handler.proxyListener, capture);
	            handlers.splice(k, 1);
	          } else if (!listener) {
	            el.removeEventListener(event, handler.proxyListener, capture);
	            handlers.splice(k, 1);
	          }
	        }
	      }
	    }
	  }

	  return this;
	}

	function trigger() {
	  var window = getWindow();

	  for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
	    args[_key9] = arguments[_key9];
	  }

	  var events = args[0].split(' ');
	  var eventData = args[1];

	  for (var i = 0; i < events.length; i += 1) {
	    var event = events[i];

	    for (var j = 0; j < this.length; j += 1) {
	      var el = this[j];

	      if (window.CustomEvent) {
	        var evt = new window.CustomEvent(event, {
	          detail: eventData,
	          bubbles: true,
	          cancelable: true
	        });
	        el.dom7EventData = args.filter(function (data, dataIndex) {
	          return dataIndex > 0;
	        });
	        el.dispatchEvent(evt);
	        el.dom7EventData = [];
	        delete el.dom7EventData;
	      }
	    }
	  }

	  return this;
	}

	function transitionEnd(callback) {
	  var dom = this;

	  function fireCallBack(e) {
	    if (e.target !== this) return;
	    callback.call(this, e);
	    dom.off('transitionend', fireCallBack);
	  }

	  if (callback) {
	    dom.on('transitionend', fireCallBack);
	  }

	  return this;
	}

	function outerWidth(includeMargins) {
	  if (this.length > 0) {
	    if (includeMargins) {
	      var _styles = this.styles();

	      return this[0].offsetWidth + parseFloat(_styles.getPropertyValue('margin-right')) + parseFloat(_styles.getPropertyValue('margin-left'));
	    }

	    return this[0].offsetWidth;
	  }

	  return null;
	}

	function outerHeight(includeMargins) {
	  if (this.length > 0) {
	    if (includeMargins) {
	      var _styles2 = this.styles();

	      return this[0].offsetHeight + parseFloat(_styles2.getPropertyValue('margin-top')) + parseFloat(_styles2.getPropertyValue('margin-bottom'));
	    }

	    return this[0].offsetHeight;
	  }

	  return null;
	}

	function offset() {
	  if (this.length > 0) {
	    var window = getWindow();
	    var document = getDocument();
	    var el = this[0];
	    var box = el.getBoundingClientRect();
	    var body = document.body;
	    var clientTop = el.clientTop || body.clientTop || 0;
	    var clientLeft = el.clientLeft || body.clientLeft || 0;
	    var scrollTop = el === window ? window.scrollY : el.scrollTop;
	    var scrollLeft = el === window ? window.scrollX : el.scrollLeft;
	    return {
	      top: box.top + scrollTop - clientTop,
	      left: box.left + scrollLeft - clientLeft
	    };
	  }

	  return null;
	}

	function styles() {
	  var window = getWindow();
	  if (this[0]) return window.getComputedStyle(this[0], null);
	  return {};
	}

	function css(props, value) {
	  var window = getWindow();
	  var i;

	  if (arguments.length === 1) {
	    if (typeof props === 'string') {
	      // .css('width')
	      if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
	    } else {
	      // .css({ width: '100px' })
	      for (i = 0; i < this.length; i += 1) {
	        for (var _prop in props) {
	          this[i].style[_prop] = props[_prop];
	        }
	      }

	      return this;
	    }
	  }

	  if (arguments.length === 2 && typeof props === 'string') {
	    // .css('width', '100px')
	    for (i = 0; i < this.length; i += 1) {
	      this[i].style[props] = value;
	    }

	    return this;
	  }

	  return this;
	}

	function each(callback) {
	  if (!callback) return this;
	  this.forEach(function (el, index) {
	    callback.apply(el, [el, index]);
	  });
	  return this;
	}

	function filter(callback) {
	  var result = arrayFilter(this, callback);
	  return $(result);
	}

	function html(html) {
	  if (typeof html === 'undefined') {
	    return this[0] ? this[0].innerHTML : null;
	  }

	  for (var i = 0; i < this.length; i += 1) {
	    this[i].innerHTML = html;
	  }

	  return this;
	}

	function text$1(text) {
	  if (typeof text === 'undefined') {
	    return this[0] ? this[0].textContent.trim() : null;
	  }

	  for (var i = 0; i < this.length; i += 1) {
	    this[i].textContent = text;
	  }

	  return this;
	}

	function is(selector) {
	  var window = getWindow();
	  var document = getDocument();
	  var el = this[0];
	  var compareWith;
	  var i;
	  if (!el || typeof selector === 'undefined') return false;

	  if (typeof selector === 'string') {
	    if (el.matches) return el.matches(selector);
	    if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
	    if (el.msMatchesSelector) return el.msMatchesSelector(selector);
	    compareWith = $(selector);

	    for (i = 0; i < compareWith.length; i += 1) {
	      if (compareWith[i] === el) return true;
	    }

	    return false;
	  }

	  if (selector === document) {
	    return el === document;
	  }

	  if (selector === window) {
	    return el === window;
	  }

	  if (selector.nodeType || selector instanceof Dom7) {
	    compareWith = selector.nodeType ? [selector] : selector;

	    for (i = 0; i < compareWith.length; i += 1) {
	      if (compareWith[i] === el) return true;
	    }

	    return false;
	  }

	  return false;
	}

	function index() {
	  var child = this[0];
	  var i;

	  if (child) {
	    i = 0; // eslint-disable-next-line

	    while ((child = child.previousSibling) !== null) {
	      if (child.nodeType === 1) i += 1;
	    }

	    return i;
	  }

	  return undefined;
	}

	function eq(index) {
	  if (typeof index === 'undefined') return this;
	  var length = this.length;

	  if (index > length - 1) {
	    return $([]);
	  }

	  if (index < 0) {
	    var returnIndex = length + index;
	    if (returnIndex < 0) return $([]);
	    return $([this[returnIndex]]);
	  }

	  return $([this[index]]);
	}

	function append$1() {
	  var newChild;
	  var document = getDocument();

	  for (var k = 0; k < arguments.length; k += 1) {
	    newChild = k < 0 || arguments.length <= k ? undefined : arguments[k];

	    for (var i = 0; i < this.length; i += 1) {
	      if (typeof newChild === 'string') {
	        var tempDiv = document.createElement('div');
	        tempDiv.innerHTML = newChild;

	        while (tempDiv.firstChild) {
	          this[i].appendChild(tempDiv.firstChild);
	        }
	      } else if (newChild instanceof Dom7) {
	        for (var j = 0; j < newChild.length; j += 1) {
	          this[i].appendChild(newChild[j]);
	        }
	      } else {
	        this[i].appendChild(newChild);
	      }
	    }
	  }

	  return this;
	}

	function prepend(newChild) {
	  var document = getDocument();
	  var i;
	  var j;

	  for (i = 0; i < this.length; i += 1) {
	    if (typeof newChild === 'string') {
	      var tempDiv = document.createElement('div');
	      tempDiv.innerHTML = newChild;

	      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
	        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
	      }
	    } else if (newChild instanceof Dom7) {
	      for (j = 0; j < newChild.length; j += 1) {
	        this[i].insertBefore(newChild[j], this[i].childNodes[0]);
	      }
	    } else {
	      this[i].insertBefore(newChild, this[i].childNodes[0]);
	    }
	  }

	  return this;
	}

	function next(selector) {
	  if (this.length > 0) {
	    if (selector) {
	      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
	        return $([this[0].nextElementSibling]);
	      }

	      return $([]);
	    }

	    if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);
	    return $([]);
	  }

	  return $([]);
	}

	function nextAll(selector) {
	  var nextEls = [];
	  var el = this[0];
	  if (!el) return $([]);

	  while (el.nextElementSibling) {
	    var _next = el.nextElementSibling; // eslint-disable-line

	    if (selector) {
	      if ($(_next).is(selector)) nextEls.push(_next);
	    } else nextEls.push(_next);

	    el = _next;
	  }

	  return $(nextEls);
	}

	function prev(selector) {
	  if (this.length > 0) {
	    var el = this[0];

	    if (selector) {
	      if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
	        return $([el.previousElementSibling]);
	      }

	      return $([]);
	    }

	    if (el.previousElementSibling) return $([el.previousElementSibling]);
	    return $([]);
	  }

	  return $([]);
	}

	function prevAll(selector) {
	  var prevEls = [];
	  var el = this[0];
	  if (!el) return $([]);

	  while (el.previousElementSibling) {
	    var _prev = el.previousElementSibling; // eslint-disable-line

	    if (selector) {
	      if ($(_prev).is(selector)) prevEls.push(_prev);
	    } else prevEls.push(_prev);

	    el = _prev;
	  }

	  return $(prevEls);
	}

	function parent(selector) {
	  var parents = []; // eslint-disable-line

	  for (var i = 0; i < this.length; i += 1) {
	    if (this[i].parentNode !== null) {
	      if (selector) {
	        if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
	      } else {
	        parents.push(this[i].parentNode);
	      }
	    }
	  }

	  return $(parents);
	}

	function parents(selector) {
	  var parents = []; // eslint-disable-line

	  for (var i = 0; i < this.length; i += 1) {
	    var _parent = this[i].parentNode; // eslint-disable-line

	    while (_parent) {
	      if (selector) {
	        if ($(_parent).is(selector)) parents.push(_parent);
	      } else {
	        parents.push(_parent);
	      }

	      _parent = _parent.parentNode;
	    }
	  }

	  return $(parents);
	}

	function closest(selector) {
	  var closest = this; // eslint-disable-line

	  if (typeof selector === 'undefined') {
	    return $([]);
	  }

	  if (!closest.is(selector)) {
	    closest = closest.parents(selector).eq(0);
	  }

	  return closest;
	}

	function find(selector) {
	  var foundElements = [];

	  for (var i = 0; i < this.length; i += 1) {
	    var found = this[i].querySelectorAll(selector);

	    for (var j = 0; j < found.length; j += 1) {
	      foundElements.push(found[j]);
	    }
	  }

	  return $(foundElements);
	}

	function children$1(selector) {
	  var children = []; // eslint-disable-line

	  for (var i = 0; i < this.length; i += 1) {
	    var childNodes = this[i].children;

	    for (var j = 0; j < childNodes.length; j += 1) {
	      if (!selector || $(childNodes[j]).is(selector)) {
	        children.push(childNodes[j]);
	      }
	    }
	  }

	  return $(children);
	}

	function remove() {
	  for (var i = 0; i < this.length; i += 1) {
	    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
	  }

	  return this;
	}

	var Methods = {
	  addClass: addClass,
	  removeClass: removeClass,
	  hasClass: hasClass,
	  toggleClass: toggleClass,
	  attr: attr$1,
	  removeAttr: removeAttr,
	  transform: transform,
	  transition: transition,
	  on: on,
	  off: off,
	  trigger: trigger,
	  transitionEnd: transitionEnd,
	  outerWidth: outerWidth,
	  outerHeight: outerHeight,
	  styles: styles,
	  offset: offset,
	  css: css,
	  each: each,
	  html: html,
	  text: text$1,
	  is: is,
	  index: index,
	  eq: eq,
	  append: append$1,
	  prepend: prepend,
	  next: next,
	  nextAll: nextAll,
	  prev: prev,
	  prevAll: prevAll,
	  parent: parent,
	  parents: parents,
	  closest: closest,
	  find: find,
	  children: children$1,
	  filter: filter,
	  remove: remove
	};
	Object.keys(Methods).forEach(function (methodName) {
	  $.fn[methodName] = Methods[methodName];
	});

	function deleteProps(obj) {
	  var object = obj;
	  Object.keys(object).forEach(function (key) {
	    try {
	      object[key] = null;
	    } catch (e) {// no getter for object
	    }

	    try {
	      delete object[key];
	    } catch (e) {// something got wrong
	    }
	  });
	}

	function nextTick(callback, delay) {
	  if (delay === void 0) {
	    delay = 0;
	  }

	  return setTimeout(callback, delay);
	}

	function now() {
	  return Date.now();
	}

	function getTranslate(el, axis) {
	  if (axis === void 0) {
	    axis = 'x';
	  }

	  var window = getWindow();
	  var matrix;
	  var curTransform;
	  var transformMatrix;
	  var curStyle = window.getComputedStyle(el, null);

	  if (window.WebKitCSSMatrix) {
	    curTransform = curStyle.transform || curStyle.webkitTransform;

	    if (curTransform.split(',').length > 6) {
	      curTransform = curTransform.split(', ').map(function (a) {
	        return a.replace(',', '.');
	      }).join(', ');
	    } // Some old versions of Webkit choke when 'none' is passed; pass
	    // empty string instead in this case


	    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
	  } else {
	    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
	    matrix = transformMatrix.toString().split(',');
	  }

	  if (axis === 'x') {
	    // Latest Chrome and webkits Fix
	    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix
	    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers
	      else curTransform = parseFloat(matrix[4]);
	  }

	  if (axis === 'y') {
	    // Latest Chrome and webkits Fix
	    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix
	    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers
	      else curTransform = parseFloat(matrix[5]);
	  }

	  return curTransform || 0;
	}

	function isObject$1(o) {
	  return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
	}

	function extend$1() {
	  var to = Object(arguments.length <= 0 ? undefined : arguments[0]);

	  for (var i = 1; i < arguments.length; i += 1) {
	    var nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];

	    if (nextSource !== undefined && nextSource !== null) {
	      var keysArray = Object.keys(Object(nextSource));

	      for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
	        var nextKey = keysArray[nextIndex];
	        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

	        if (desc !== undefined && desc.enumerable) {
	          if (isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
	            extend$1(to[nextKey], nextSource[nextKey]);
	          } else if (!isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
	            to[nextKey] = {};
	            extend$1(to[nextKey], nextSource[nextKey]);
	          } else {
	            to[nextKey] = nextSource[nextKey];
	          }
	        }
	      }
	    }
	  }

	  return to;
	}

	function bindModuleMethods(instance, obj) {
	  Object.keys(obj).forEach(function (key) {
	    if (isObject$1(obj[key])) {
	      Object.keys(obj[key]).forEach(function (subKey) {
	        if (typeof obj[key][subKey] === 'function') {
	          obj[key][subKey] = obj[key][subKey].bind(instance);
	        }
	      });
	    }

	    instance[key] = obj[key];
	  });
	}

	var support;

	function calcSupport() {
	  var window = getWindow();
	  var document = getDocument();
	  return {
	    touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
	    pointerEvents: !!window.PointerEvent && 'maxTouchPoints' in window.navigator && window.navigator.maxTouchPoints >= 0,
	    observer: function checkObserver() {
	      return 'MutationObserver' in window || 'WebkitMutationObserver' in window;
	    }(),
	    passiveListener: function checkPassiveListener() {
	      var supportsPassive = false;

	      try {
	        var opts = Object.defineProperty({}, 'passive', {
	          // eslint-disable-next-line
	          get: function get() {
	            supportsPassive = true;
	          }
	        });
	        window.addEventListener('testPassiveListener', null, opts);
	      } catch (e) {// No support
	      }

	      return supportsPassive;
	    }(),
	    gestures: function checkGestures() {
	      return 'ongesturestart' in window;
	    }()
	  };
	}

	function getSupport() {
	  if (!support) {
	    support = calcSupport();
	  }

	  return support;
	}

	var device;

	function calcDevice(_temp) {
	  var _ref = _temp === void 0 ? {} : _temp,
	      userAgent = _ref.userAgent;

	  var support = getSupport();
	  var window = getWindow();
	  var platform = window.navigator.platform;
	  var ua = userAgent || window.navigator.userAgent;
	  var device = {
	    ios: false,
	    android: false
	  };
	  var screenWidth = window.screen.width;
	  var screenHeight = window.screen.height;
	  var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

	  var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
	  var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
	  var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
	  var windows = platform === 'Win32';
	  var macos = platform === 'MacIntel'; // iPadOs 13 fix

	  var iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];

	  if (!ipad && macos && support.touch && iPadScreens.indexOf(screenWidth + "x" + screenHeight) >= 0) {
	    ipad = ua.match(/(Version)\/([\d.]+)/);
	    if (!ipad) ipad = [0, 1, '13_0_0'];
	    macos = false;
	  } // Android


	  if (android && !windows) {
	    device.os = 'android';
	    device.android = true;
	  }

	  if (ipad || iphone || ipod) {
	    device.os = 'ios';
	    device.ios = true;
	  } // Export object


	  return device;
	}

	function getDevice(overrides) {
	  if (overrides === void 0) {
	    overrides = {};
	  }

	  if (!device) {
	    device = calcDevice(overrides);
	  }

	  return device;
	}

	var browser;

	function calcBrowser() {
	  var window = getWindow();

	  function isSafari() {
	    var ua = window.navigator.userAgent.toLowerCase();
	    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
	  }

	  return {
	    isEdge: !!window.navigator.userAgent.match(/Edge/g),
	    isSafari: isSafari(),
	    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
	  };
	}

	function getBrowser() {
	  if (!browser) {
	    browser = calcBrowser();
	  }

	  return browser;
	}

	var Resize = {
	  name: 'resize',
	  create: function create() {
	    var swiper = this;
	    extend$1(swiper, {
	      resize: {
	        resizeHandler: function resizeHandler() {
	          if (!swiper || swiper.destroyed || !swiper.initialized) return;
	          swiper.emit('beforeResize');
	          swiper.emit('resize');
	        },
	        orientationChangeHandler: function orientationChangeHandler() {
	          if (!swiper || swiper.destroyed || !swiper.initialized) return;
	          swiper.emit('orientationchange');
	        }
	      }
	    });
	  },
	  on: {
	    init: function init(swiper) {
	      var window = getWindow(); // Emit resize

	      window.addEventListener('resize', swiper.resize.resizeHandler); // Emit orientationchange

	      window.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
	    },
	    destroy: function destroy(swiper) {
	      var window = getWindow();
	      window.removeEventListener('resize', swiper.resize.resizeHandler);
	      window.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
	    }
	  }
	};

	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
	var Observer = {
	  attach: function attach(target, options) {
	    if (options === void 0) {
	      options = {};
	    }

	    var window = getWindow();
	    var swiper = this;
	    var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
	    var observer = new ObserverFunc(function (mutations) {
	      // The observerUpdate event should only be triggered
	      // once despite the number of mutations.  Additional
	      // triggers are redundant and are very costly
	      if (mutations.length === 1) {
	        swiper.emit('observerUpdate', mutations[0]);
	        return;
	      }

	      var observerUpdate = function observerUpdate() {
	        swiper.emit('observerUpdate', mutations[0]);
	      };

	      if (window.requestAnimationFrame) {
	        window.requestAnimationFrame(observerUpdate);
	      } else {
	        window.setTimeout(observerUpdate, 0);
	      }
	    });
	    observer.observe(target, {
	      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
	      childList: typeof options.childList === 'undefined' ? true : options.childList,
	      characterData: typeof options.characterData === 'undefined' ? true : options.characterData
	    });
	    swiper.observer.observers.push(observer);
	  },
	  init: function init() {
	    var swiper = this;
	    if (!swiper.support.observer || !swiper.params.observer) return;

	    if (swiper.params.observeParents) {
	      var containerParents = swiper.$el.parents();

	      for (var i = 0; i < containerParents.length; i += 1) {
	        swiper.observer.attach(containerParents[i]);
	      }
	    } // Observe container


	    swiper.observer.attach(swiper.$el[0], {
	      childList: swiper.params.observeSlideChildren
	    }); // Observe wrapper

	    swiper.observer.attach(swiper.$wrapperEl[0], {
	      attributes: false
	    });
	  },
	  destroy: function destroy() {
	    var swiper = this;
	    swiper.observer.observers.forEach(function (observer) {
	      observer.disconnect();
	    });
	    swiper.observer.observers = [];
	  }
	};
	var Observer$1 = {
	  name: 'observer',
	  params: {
	    observer: false,
	    observeParents: false,
	    observeSlideChildren: false
	  },
	  create: function create() {
	    var swiper = this;
	    bindModuleMethods(swiper, {
	      observer: _extends(_extends({}, Observer), {}, {
	        observers: []
	      })
	    });
	  },
	  on: {
	    init: function init(swiper) {
	      swiper.observer.init();
	    },
	    destroy: function destroy(swiper) {
	      swiper.observer.destroy();
	    }
	  }
	};

	var modular = {
	  useParams: function useParams(instanceParams) {
	    var instance = this;
	    if (!instance.modules) return;
	    Object.keys(instance.modules).forEach(function (moduleName) {
	      var module = instance.modules[moduleName]; // Extend params

	      if (module.params) {
	        extend$1(instanceParams, module.params);
	      }
	    });
	  },
	  useModules: function useModules(modulesParams) {
	    if (modulesParams === void 0) {
	      modulesParams = {};
	    }

	    var instance = this;
	    if (!instance.modules) return;
	    Object.keys(instance.modules).forEach(function (moduleName) {
	      var module = instance.modules[moduleName];
	      var moduleParams = modulesParams[moduleName] || {}; // Add event listeners

	      if (module.on && instance.on) {
	        Object.keys(module.on).forEach(function (moduleEventName) {
	          instance.on(moduleEventName, module.on[moduleEventName]);
	        });
	      } // Module create callback


	      if (module.create) {
	        module.create.bind(instance)(moduleParams);
	      }
	    });
	  }
	};

	/* eslint-disable no-underscore-dangle */
	var eventsEmitter = {
	  on: function on(events, handler, priority) {
	    var self = this;
	    if (typeof handler !== 'function') return self;
	    var method = priority ? 'unshift' : 'push';
	    events.split(' ').forEach(function (event) {
	      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
	      self.eventsListeners[event][method](handler);
	    });
	    return self;
	  },
	  once: function once(events, handler, priority) {
	    var self = this;
	    if (typeof handler !== 'function') return self;

	    function onceHandler() {
	      self.off(events, onceHandler);

	      if (onceHandler.__emitterProxy) {
	        delete onceHandler.__emitterProxy;
	      }

	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      handler.apply(self, args);
	    }

	    onceHandler.__emitterProxy = handler;
	    return self.on(events, onceHandler, priority);
	  },
	  onAny: function onAny(handler, priority) {
	    var self = this;
	    if (typeof handler !== 'function') return self;
	    var method = priority ? 'unshift' : 'push';

	    if (self.eventsAnyListeners.indexOf(handler) < 0) {
	      self.eventsAnyListeners[method](handler);
	    }

	    return self;
	  },
	  offAny: function offAny(handler) {
	    var self = this;
	    if (!self.eventsAnyListeners) return self;
	    var index = self.eventsAnyListeners.indexOf(handler);

	    if (index >= 0) {
	      self.eventsAnyListeners.splice(index, 1);
	    }

	    return self;
	  },
	  off: function off(events, handler) {
	    var self = this;
	    if (!self.eventsListeners) return self;
	    events.split(' ').forEach(function (event) {
	      if (typeof handler === 'undefined') {
	        self.eventsListeners[event] = [];
	      } else if (self.eventsListeners[event]) {
	        self.eventsListeners[event].forEach(function (eventHandler, index) {
	          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
	            self.eventsListeners[event].splice(index, 1);
	          }
	        });
	      }
	    });
	    return self;
	  },
	  emit: function emit() {
	    var self = this;
	    if (!self.eventsListeners) return self;
	    var events;
	    var data;
	    var context;

	    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	      args[_key2] = arguments[_key2];
	    }

	    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
	      events = args[0];
	      data = args.slice(1, args.length);
	      context = self;
	    } else {
	      events = args[0].events;
	      data = args[0].data;
	      context = args[0].context || self;
	    }

	    data.unshift(context);
	    var eventsArray = Array.isArray(events) ? events : events.split(' ');
	    eventsArray.forEach(function (event) {
	      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
	        self.eventsAnyListeners.forEach(function (eventHandler) {
	          eventHandler.apply(context, [event].concat(data));
	        });
	      }

	      if (self.eventsListeners && self.eventsListeners[event]) {
	        self.eventsListeners[event].forEach(function (eventHandler) {
	          eventHandler.apply(context, data);
	        });
	      }
	    });
	    return self;
	  }
	};

	function updateSize() {
	  var swiper = this;
	  var width;
	  var height;
	  var $el = swiper.$el;

	  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
	    width = swiper.params.width;
	  } else {
	    width = $el[0].clientWidth;
	  }

	  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
	    height = swiper.params.height;
	  } else {
	    height = $el[0].clientHeight;
	  }

	  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
	    return;
	  } // Subtract paddings


	  width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
	  height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
	  if (Number.isNaN(width)) width = 0;
	  if (Number.isNaN(height)) height = 0;
	  extend$1(swiper, {
	    width: width,
	    height: height,
	    size: swiper.isHorizontal() ? width : height
	  });
	}

	function updateSlides() {
	  var swiper = this;
	  var window = getWindow();
	  var params = swiper.params;
	  var $wrapperEl = swiper.$wrapperEl,
	      swiperSize = swiper.size,
	      rtl = swiper.rtlTranslate,
	      wrongRTL = swiper.wrongRTL;
	  var isVirtual = swiper.virtual && params.virtual.enabled;
	  var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
	  var slides = $wrapperEl.children("." + swiper.params.slideClass);
	  var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
	  var snapGrid = [];
	  var slidesGrid = [];
	  var slidesSizesGrid = [];

	  function slidesForMargin(slideEl, slideIndex) {
	    if (!params.cssMode) return true;

	    if (slideIndex === slides.length - 1) {
	      return false;
	    }

	    return true;
	  }

	  var offsetBefore = params.slidesOffsetBefore;

	  if (typeof offsetBefore === 'function') {
	    offsetBefore = params.slidesOffsetBefore.call(swiper);
	  }

	  var offsetAfter = params.slidesOffsetAfter;

	  if (typeof offsetAfter === 'function') {
	    offsetAfter = params.slidesOffsetAfter.call(swiper);
	  }

	  var previousSnapGridLength = swiper.snapGrid.length;
	  var previousSlidesGridLength = swiper.snapGrid.length;
	  var spaceBetween = params.spaceBetween;
	  var slidePosition = -offsetBefore;
	  var prevSlideSize = 0;
	  var index = 0;

	  if (typeof swiperSize === 'undefined') {
	    return;
	  }

	  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
	    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
	  }

	  swiper.virtualSize = -spaceBetween; // reset margins

	  if (rtl) slides.css({
	    marginLeft: '',
	    marginTop: ''
	  });else slides.css({
	    marginRight: '',
	    marginBottom: ''
	  });
	  var slidesNumberEvenToRows;

	  if (params.slidesPerColumn > 1) {
	    if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
	      slidesNumberEvenToRows = slidesLength;
	    } else {
	      slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
	    }

	    if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
	      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
	    }
	  } // Calc slides


	  var slideSize;
	  var slidesPerColumn = params.slidesPerColumn;
	  var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
	  var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);

	  for (var i = 0; i < slidesLength; i += 1) {
	    slideSize = 0;
	    var slide = slides.eq(i);

	    if (params.slidesPerColumn > 1) {
	      // Set slides order
	      var newSlideOrderIndex = void 0;
	      var column = void 0;
	      var row = void 0;

	      if (params.slidesPerColumnFill === 'row' && params.slidesPerGroup > 1) {
	        var groupIndex = Math.floor(i / (params.slidesPerGroup * params.slidesPerColumn));
	        var slideIndexInGroup = i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
	        var columnsInGroup = groupIndex === 0 ? params.slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);
	        row = Math.floor(slideIndexInGroup / columnsInGroup);
	        column = slideIndexInGroup - row * columnsInGroup + groupIndex * params.slidesPerGroup;
	        newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
	        slide.css({
	          '-webkit-box-ordinal-group': newSlideOrderIndex,
	          '-moz-box-ordinal-group': newSlideOrderIndex,
	          '-ms-flex-order': newSlideOrderIndex,
	          '-webkit-order': newSlideOrderIndex,
	          order: newSlideOrderIndex
	        });
	      } else if (params.slidesPerColumnFill === 'column') {
	        column = Math.floor(i / slidesPerColumn);
	        row = i - column * slidesPerColumn;

	        if (column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1) {
	          row += 1;

	          if (row >= slidesPerColumn) {
	            row = 0;
	            column += 1;
	          }
	        }
	      } else {
	        row = Math.floor(i / slidesPerRow);
	        column = i - row * slidesPerRow;
	      }

	      slide.css("margin-" + (swiper.isHorizontal() ? 'top' : 'left'), row !== 0 && params.spaceBetween && params.spaceBetween + "px");
	    }

	    if (slide.css('display') === 'none') continue; // eslint-disable-line

	    if (params.slidesPerView === 'auto') {
	      var slideStyles = window.getComputedStyle(slide[0], null);
	      var currentTransform = slide[0].style.transform;
	      var currentWebKitTransform = slide[0].style.webkitTransform;

	      if (currentTransform) {
	        slide[0].style.transform = 'none';
	      }

	      if (currentWebKitTransform) {
	        slide[0].style.webkitTransform = 'none';
	      }

	      if (params.roundLengths) {
	        slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
	      } else {
	        // eslint-disable-next-line
	        if (swiper.isHorizontal()) {
	          var width = parseFloat(slideStyles.getPropertyValue('width') || 0);
	          var paddingLeft = parseFloat(slideStyles.getPropertyValue('padding-left') || 0);
	          var paddingRight = parseFloat(slideStyles.getPropertyValue('padding-right') || 0);
	          var marginLeft = parseFloat(slideStyles.getPropertyValue('margin-left') || 0);
	          var marginRight = parseFloat(slideStyles.getPropertyValue('margin-right') || 0);
	          var boxSizing = slideStyles.getPropertyValue('box-sizing');

	          if (boxSizing && boxSizing === 'border-box') {
	            slideSize = width + marginLeft + marginRight;
	          } else {
	            var _slide$ = slide[0],
	                clientWidth = _slide$.clientWidth,
	                offsetWidth = _slide$.offsetWidth;
	            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
	          }
	        } else {
	          var height = parseFloat(slideStyles.getPropertyValue('height') || 0);
	          var paddingTop = parseFloat(slideStyles.getPropertyValue('padding-top') || 0);
	          var paddingBottom = parseFloat(slideStyles.getPropertyValue('padding-bottom') || 0);
	          var marginTop = parseFloat(slideStyles.getPropertyValue('margin-top') || 0);
	          var marginBottom = parseFloat(slideStyles.getPropertyValue('margin-bottom') || 0);

	          var _boxSizing = slideStyles.getPropertyValue('box-sizing');

	          if (_boxSizing && _boxSizing === 'border-box') {
	            slideSize = height + marginTop + marginBottom;
	          } else {
	            var _slide$2 = slide[0],
	                clientHeight = _slide$2.clientHeight,
	                offsetHeight = _slide$2.offsetHeight;
	            slideSize = height + paddingTop + paddingBottom + marginTop + marginBottom + (offsetHeight - clientHeight);
	          }
	        }
	      }

	      if (currentTransform) {
	        slide[0].style.transform = currentTransform;
	      }

	      if (currentWebKitTransform) {
	        slide[0].style.webkitTransform = currentWebKitTransform;
	      }

	      if (params.roundLengths) slideSize = Math.floor(slideSize);
	    } else {
	      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
	      if (params.roundLengths) slideSize = Math.floor(slideSize);

	      if (slides[i]) {
	        if (swiper.isHorizontal()) {
	          slides[i].style.width = slideSize + "px";
	        } else {
	          slides[i].style.height = slideSize + "px";
	        }
	      }
	    }

	    if (slides[i]) {
	      slides[i].swiperSlideSize = slideSize;
	    }

	    slidesSizesGrid.push(slideSize);

	    if (params.centeredSlides) {
	      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
	      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
	      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
	      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
	      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
	      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
	      slidesGrid.push(slidePosition);
	    } else {
	      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
	      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
	      slidesGrid.push(slidePosition);
	      slidePosition = slidePosition + slideSize + spaceBetween;
	    }

	    swiper.virtualSize += slideSize + spaceBetween;
	    prevSlideSize = slideSize;
	    index += 1;
	  }

	  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
	  var newSlidesGrid;

	  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
	    $wrapperEl.css({
	      width: swiper.virtualSize + params.spaceBetween + "px"
	    });
	  }

	  if (params.setWrapperSize) {
	    if (swiper.isHorizontal()) $wrapperEl.css({
	      width: swiper.virtualSize + params.spaceBetween + "px"
	    });else $wrapperEl.css({
	      height: swiper.virtualSize + params.spaceBetween + "px"
	    });
	  }

	  if (params.slidesPerColumn > 1) {
	    swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
	    swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
	    if (swiper.isHorizontal()) $wrapperEl.css({
	      width: swiper.virtualSize + params.spaceBetween + "px"
	    });else $wrapperEl.css({
	      height: swiper.virtualSize + params.spaceBetween + "px"
	    });

	    if (params.centeredSlides) {
	      newSlidesGrid = [];

	      for (var _i = 0; _i < snapGrid.length; _i += 1) {
	        var slidesGridItem = snapGrid[_i];
	        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
	        if (snapGrid[_i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
	      }

	      snapGrid = newSlidesGrid;
	    }
	  } // Remove last grid elements depending on width


	  if (!params.centeredSlides) {
	    newSlidesGrid = [];

	    for (var _i2 = 0; _i2 < snapGrid.length; _i2 += 1) {
	      var _slidesGridItem = snapGrid[_i2];
	      if (params.roundLengths) _slidesGridItem = Math.floor(_slidesGridItem);

	      if (snapGrid[_i2] <= swiper.virtualSize - swiperSize) {
	        newSlidesGrid.push(_slidesGridItem);
	      }
	    }

	    snapGrid = newSlidesGrid;

	    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
	      snapGrid.push(swiper.virtualSize - swiperSize);
	    }
	  }

	  if (snapGrid.length === 0) snapGrid = [0];

	  if (params.spaceBetween !== 0) {
	    if (swiper.isHorizontal()) {
	      if (rtl) slides.filter(slidesForMargin).css({
	        marginLeft: spaceBetween + "px"
	      });else slides.filter(slidesForMargin).css({
	        marginRight: spaceBetween + "px"
	      });
	    } else slides.filter(slidesForMargin).css({
	      marginBottom: spaceBetween + "px"
	    });
	  }

	  if (params.centeredSlides && params.centeredSlidesBounds) {
	    var allSlidesSize = 0;
	    slidesSizesGrid.forEach(function (slideSizeValue) {
	      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
	    });
	    allSlidesSize -= params.spaceBetween;
	    var maxSnap = allSlidesSize - swiperSize;
	    snapGrid = snapGrid.map(function (snap) {
	      if (snap < 0) return -offsetBefore;
	      if (snap > maxSnap) return maxSnap + offsetAfter;
	      return snap;
	    });
	  }

	  if (params.centerInsufficientSlides) {
	    var _allSlidesSize = 0;
	    slidesSizesGrid.forEach(function (slideSizeValue) {
	      _allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
	    });
	    _allSlidesSize -= params.spaceBetween;

	    if (_allSlidesSize < swiperSize) {
	      var allSlidesOffset = (swiperSize - _allSlidesSize) / 2;
	      snapGrid.forEach(function (snap, snapIndex) {
	        snapGrid[snapIndex] = snap - allSlidesOffset;
	      });
	      slidesGrid.forEach(function (snap, snapIndex) {
	        slidesGrid[snapIndex] = snap + allSlidesOffset;
	      });
	    }
	  }

	  extend$1(swiper, {
	    slides: slides,
	    snapGrid: snapGrid,
	    slidesGrid: slidesGrid,
	    slidesSizesGrid: slidesSizesGrid
	  });

	  if (slidesLength !== previousSlidesLength) {
	    swiper.emit('slidesLengthChange');
	  }

	  if (snapGrid.length !== previousSnapGridLength) {
	    if (swiper.params.watchOverflow) swiper.checkOverflow();
	    swiper.emit('snapGridLengthChange');
	  }

	  if (slidesGrid.length !== previousSlidesGridLength) {
	    swiper.emit('slidesGridLengthChange');
	  }

	  if (params.watchSlidesProgress || params.watchSlidesVisibility) {
	    swiper.updateSlidesOffset();
	  }
	}

	function updateAutoHeight(speed) {
	  var swiper = this;
	  var activeSlides = [];
	  var newHeight = 0;
	  var i;

	  if (typeof speed === 'number') {
	    swiper.setTransition(speed);
	  } else if (speed === true) {
	    swiper.setTransition(swiper.params.speed);
	  } // Find slides currently in view


	  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
	    if (swiper.params.centeredSlides) {
	      swiper.visibleSlides.each(function (slide) {
	        activeSlides.push(slide);
	      });
	    } else {
	      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
	        var index = swiper.activeIndex + i;
	        if (index > swiper.slides.length) break;
	        activeSlides.push(swiper.slides.eq(index)[0]);
	      }
	    }
	  } else {
	    activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
	  } // Find new height from highest slide in view


	  for (i = 0; i < activeSlides.length; i += 1) {
	    if (typeof activeSlides[i] !== 'undefined') {
	      var height = activeSlides[i].offsetHeight;
	      newHeight = height > newHeight ? height : newHeight;
	    }
	  } // Update Height


	  if (newHeight) swiper.$wrapperEl.css('height', newHeight + "px");
	}

	function updateSlidesOffset() {
	  var swiper = this;
	  var slides = swiper.slides;

	  for (var i = 0; i < slides.length; i += 1) {
	    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
	  }
	}

	function updateSlidesProgress(translate) {
	  if (translate === void 0) {
	    translate = this && this.translate || 0;
	  }

	  var swiper = this;
	  var params = swiper.params;
	  var slides = swiper.slides,
	      rtl = swiper.rtlTranslate;
	  if (slides.length === 0) return;
	  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
	  var offsetCenter = -translate;
	  if (rtl) offsetCenter = translate; // Visible Slides

	  slides.removeClass(params.slideVisibleClass);
	  swiper.visibleSlidesIndexes = [];
	  swiper.visibleSlides = [];

	  for (var i = 0; i < slides.length; i += 1) {
	    var slide = slides[i];
	    var slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + params.spaceBetween);

	    if (params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) {
	      var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
	      var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
	      var isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;

	      if (isVisible) {
	        swiper.visibleSlides.push(slide);
	        swiper.visibleSlidesIndexes.push(i);
	        slides.eq(i).addClass(params.slideVisibleClass);
	      }
	    }

	    slide.progress = rtl ? -slideProgress : slideProgress;
	  }

	  swiper.visibleSlides = $(swiper.visibleSlides);
	}

	function updateProgress(translate) {
	  var swiper = this;

	  if (typeof translate === 'undefined') {
	    var multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line

	    translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
	  }

	  var params = swiper.params;
	  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
	  var progress = swiper.progress,
	      isBeginning = swiper.isBeginning,
	      isEnd = swiper.isEnd;
	  var wasBeginning = isBeginning;
	  var wasEnd = isEnd;

	  if (translatesDiff === 0) {
	    progress = 0;
	    isBeginning = true;
	    isEnd = true;
	  } else {
	    progress = (translate - swiper.minTranslate()) / translatesDiff;
	    isBeginning = progress <= 0;
	    isEnd = progress >= 1;
	  }

	  extend$1(swiper, {
	    progress: progress,
	    isBeginning: isBeginning,
	    isEnd: isEnd
	  });
	  if (params.watchSlidesProgress || params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);

	  if (isBeginning && !wasBeginning) {
	    swiper.emit('reachBeginning toEdge');
	  }

	  if (isEnd && !wasEnd) {
	    swiper.emit('reachEnd toEdge');
	  }

	  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
	    swiper.emit('fromEdge');
	  }

	  swiper.emit('progress', progress);
	}

	function updateSlidesClasses() {
	  var swiper = this;
	  var slides = swiper.slides,
	      params = swiper.params,
	      $wrapperEl = swiper.$wrapperEl,
	      activeIndex = swiper.activeIndex,
	      realIndex = swiper.realIndex;
	  var isVirtual = swiper.virtual && params.virtual.enabled;
	  slides.removeClass(params.slideActiveClass + " " + params.slideNextClass + " " + params.slidePrevClass + " " + params.slideDuplicateActiveClass + " " + params.slideDuplicateNextClass + " " + params.slideDuplicatePrevClass);
	  var activeSlide;

	  if (isVirtual) {
	    activeSlide = swiper.$wrapperEl.find("." + params.slideClass + "[data-swiper-slide-index=\"" + activeIndex + "\"]");
	  } else {
	    activeSlide = slides.eq(activeIndex);
	  } // Active classes


	  activeSlide.addClass(params.slideActiveClass);

	  if (params.loop) {
	    // Duplicate to all looped slides
	    if (activeSlide.hasClass(params.slideDuplicateClass)) {
	      $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + realIndex + "\"]").addClass(params.slideDuplicateActiveClass);
	    } else {
	      $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + realIndex + "\"]").addClass(params.slideDuplicateActiveClass);
	    }
	  } // Next Slide


	  var nextSlide = activeSlide.nextAll("." + params.slideClass).eq(0).addClass(params.slideNextClass);

	  if (params.loop && nextSlide.length === 0) {
	    nextSlide = slides.eq(0);
	    nextSlide.addClass(params.slideNextClass);
	  } // Prev Slide


	  var prevSlide = activeSlide.prevAll("." + params.slideClass).eq(0).addClass(params.slidePrevClass);

	  if (params.loop && prevSlide.length === 0) {
	    prevSlide = slides.eq(-1);
	    prevSlide.addClass(params.slidePrevClass);
	  }

	  if (params.loop) {
	    // Duplicate to all looped slides
	    if (nextSlide.hasClass(params.slideDuplicateClass)) {
	      $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + nextSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicateNextClass);
	    } else {
	      $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + nextSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicateNextClass);
	    }

	    if (prevSlide.hasClass(params.slideDuplicateClass)) {
	      $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + prevSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicatePrevClass);
	    } else {
	      $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + prevSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicatePrevClass);
	    }
	  }

	  swiper.emitSlidesClasses();
	}

	function updateActiveIndex(newActiveIndex) {
	  var swiper = this;
	  var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
	  var slidesGrid = swiper.slidesGrid,
	      snapGrid = swiper.snapGrid,
	      params = swiper.params,
	      previousIndex = swiper.activeIndex,
	      previousRealIndex = swiper.realIndex,
	      previousSnapIndex = swiper.snapIndex;
	  var activeIndex = newActiveIndex;
	  var snapIndex;

	  if (typeof activeIndex === 'undefined') {
	    for (var i = 0; i < slidesGrid.length; i += 1) {
	      if (typeof slidesGrid[i + 1] !== 'undefined') {
	        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
	          activeIndex = i;
	        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
	          activeIndex = i + 1;
	        }
	      } else if (translate >= slidesGrid[i]) {
	        activeIndex = i;
	      }
	    } // Normalize slideIndex


	    if (params.normalizeSlideIndex) {
	      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
	    }
	  }

	  if (snapGrid.indexOf(translate) >= 0) {
	    snapIndex = snapGrid.indexOf(translate);
	  } else {
	    var skip = Math.min(params.slidesPerGroupSkip, activeIndex);
	    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
	  }

	  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

	  if (activeIndex === previousIndex) {
	    if (snapIndex !== previousSnapIndex) {
	      swiper.snapIndex = snapIndex;
	      swiper.emit('snapIndexChange');
	    }

	    return;
	  } // Get real index


	  var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
	  extend$1(swiper, {
	    snapIndex: snapIndex,
	    realIndex: realIndex,
	    previousIndex: previousIndex,
	    activeIndex: activeIndex
	  });
	  swiper.emit('activeIndexChange');
	  swiper.emit('snapIndexChange');

	  if (previousRealIndex !== realIndex) {
	    swiper.emit('realIndexChange');
	  }

	  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
	    swiper.emit('slideChange');
	  }
	}

	function updateClickedSlide(e) {
	  var swiper = this;
	  var params = swiper.params;
	  var slide = $(e.target).closest("." + params.slideClass)[0];
	  var slideFound = false;

	  if (slide) {
	    for (var i = 0; i < swiper.slides.length; i += 1) {
	      if (swiper.slides[i] === slide) slideFound = true;
	    }
	  }

	  if (slide && slideFound) {
	    swiper.clickedSlide = slide;

	    if (swiper.virtual && swiper.params.virtual.enabled) {
	      swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
	    } else {
	      swiper.clickedIndex = $(slide).index();
	    }
	  } else {
	    swiper.clickedSlide = undefined;
	    swiper.clickedIndex = undefined;
	    return;
	  }

	  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
	    swiper.slideToClickedSlide();
	  }
	}

	var update$1 = {
	  updateSize: updateSize,
	  updateSlides: updateSlides,
	  updateAutoHeight: updateAutoHeight,
	  updateSlidesOffset: updateSlidesOffset,
	  updateSlidesProgress: updateSlidesProgress,
	  updateProgress: updateProgress,
	  updateSlidesClasses: updateSlidesClasses,
	  updateActiveIndex: updateActiveIndex,
	  updateClickedSlide: updateClickedSlide
	};

	function getSwiperTranslate(axis) {
	  if (axis === void 0) {
	    axis = this.isHorizontal() ? 'x' : 'y';
	  }

	  var swiper = this;
	  var params = swiper.params,
	      rtl = swiper.rtlTranslate,
	      translate = swiper.translate,
	      $wrapperEl = swiper.$wrapperEl;

	  if (params.virtualTranslate) {
	    return rtl ? -translate : translate;
	  }

	  if (params.cssMode) {
	    return translate;
	  }

	  var currentTranslate = getTranslate($wrapperEl[0], axis);
	  if (rtl) currentTranslate = -currentTranslate;
	  return currentTranslate || 0;
	}

	function setTranslate(translate, byController) {
	  var swiper = this;
	  var rtl = swiper.rtlTranslate,
	      params = swiper.params,
	      $wrapperEl = swiper.$wrapperEl,
	      wrapperEl = swiper.wrapperEl,
	      progress = swiper.progress;
	  var x = 0;
	  var y = 0;
	  var z = 0;

	  if (swiper.isHorizontal()) {
	    x = rtl ? -translate : translate;
	  } else {
	    y = translate;
	  }

	  if (params.roundLengths) {
	    x = Math.floor(x);
	    y = Math.floor(y);
	  }

	  if (params.cssMode) {
	    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
	  } else if (!params.virtualTranslate) {
	    $wrapperEl.transform("translate3d(" + x + "px, " + y + "px, " + z + "px)");
	  }

	  swiper.previousTranslate = swiper.translate;
	  swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

	  var newProgress;
	  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

	  if (translatesDiff === 0) {
	    newProgress = 0;
	  } else {
	    newProgress = (translate - swiper.minTranslate()) / translatesDiff;
	  }

	  if (newProgress !== progress) {
	    swiper.updateProgress(translate);
	  }

	  swiper.emit('setTranslate', swiper.translate, byController);
	}

	function minTranslate() {
	  return -this.snapGrid[0];
	}

	function maxTranslate() {
	  return -this.snapGrid[this.snapGrid.length - 1];
	}

	function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
	  if (translate === void 0) {
	    translate = 0;
	  }

	  if (speed === void 0) {
	    speed = this.params.speed;
	  }

	  if (runCallbacks === void 0) {
	    runCallbacks = true;
	  }

	  if (translateBounds === void 0) {
	    translateBounds = true;
	  }

	  var swiper = this;
	  var params = swiper.params,
	      wrapperEl = swiper.wrapperEl;

	  if (swiper.animating && params.preventInteractionOnTransition) {
	    return false;
	  }

	  var minTranslate = swiper.minTranslate();
	  var maxTranslate = swiper.maxTranslate();
	  var newTranslate;
	  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate; // Update progress

	  swiper.updateProgress(newTranslate);

	  if (params.cssMode) {
	    var isH = swiper.isHorizontal();

	    if (speed === 0) {
	      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
	    } else {
	      // eslint-disable-next-line
	      if (wrapperEl.scrollTo) {
	        var _wrapperEl$scrollTo;

	        wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? 'left' : 'top'] = -newTranslate, _wrapperEl$scrollTo.behavior = 'smooth', _wrapperEl$scrollTo));
	      } else {
	        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
	      }
	    }

	    return true;
	  }

	  if (speed === 0) {
	    swiper.setTransition(0);
	    swiper.setTranslate(newTranslate);

	    if (runCallbacks) {
	      swiper.emit('beforeTransitionStart', speed, internal);
	      swiper.emit('transitionEnd');
	    }
	  } else {
	    swiper.setTransition(speed);
	    swiper.setTranslate(newTranslate);

	    if (runCallbacks) {
	      swiper.emit('beforeTransitionStart', speed, internal);
	      swiper.emit('transitionStart');
	    }

	    if (!swiper.animating) {
	      swiper.animating = true;

	      if (!swiper.onTranslateToWrapperTransitionEnd) {
	        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
	          if (!swiper || swiper.destroyed) return;
	          if (e.target !== this) return;
	          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
	          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
	          swiper.onTranslateToWrapperTransitionEnd = null;
	          delete swiper.onTranslateToWrapperTransitionEnd;

	          if (runCallbacks) {
	            swiper.emit('transitionEnd');
	          }
	        };
	      }

	      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
	      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
	    }
	  }

	  return true;
	}

	var translate = {
	  getTranslate: getSwiperTranslate,
	  setTranslate: setTranslate,
	  minTranslate: minTranslate,
	  maxTranslate: maxTranslate,
	  translateTo: translateTo
	};

	function setTransition(duration, byController) {
	  var swiper = this;

	  if (!swiper.params.cssMode) {
	    swiper.$wrapperEl.transition(duration);
	  }

	  swiper.emit('setTransition', duration, byController);
	}

	function transitionStart(runCallbacks, direction) {
	  if (runCallbacks === void 0) {
	    runCallbacks = true;
	  }

	  var swiper = this;
	  var activeIndex = swiper.activeIndex,
	      params = swiper.params,
	      previousIndex = swiper.previousIndex;
	  if (params.cssMode) return;

	  if (params.autoHeight) {
	    swiper.updateAutoHeight();
	  }

	  var dir = direction;

	  if (!dir) {
	    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
	  }

	  swiper.emit('transitionStart');

	  if (runCallbacks && activeIndex !== previousIndex) {
	    if (dir === 'reset') {
	      swiper.emit('slideResetTransitionStart');
	      return;
	    }

	    swiper.emit('slideChangeTransitionStart');

	    if (dir === 'next') {
	      swiper.emit('slideNextTransitionStart');
	    } else {
	      swiper.emit('slidePrevTransitionStart');
	    }
	  }
	}

	function transitionEnd$1(runCallbacks, direction) {
	  if (runCallbacks === void 0) {
	    runCallbacks = true;
	  }

	  var swiper = this;
	  var activeIndex = swiper.activeIndex,
	      previousIndex = swiper.previousIndex,
	      params = swiper.params;
	  swiper.animating = false;
	  if (params.cssMode) return;
	  swiper.setTransition(0);
	  var dir = direction;

	  if (!dir) {
	    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
	  }

	  swiper.emit('transitionEnd');

	  if (runCallbacks && activeIndex !== previousIndex) {
	    if (dir === 'reset') {
	      swiper.emit('slideResetTransitionEnd');
	      return;
	    }

	    swiper.emit('slideChangeTransitionEnd');

	    if (dir === 'next') {
	      swiper.emit('slideNextTransitionEnd');
	    } else {
	      swiper.emit('slidePrevTransitionEnd');
	    }
	  }
	}

	var transition$1 = {
	  setTransition: setTransition,
	  transitionStart: transitionStart,
	  transitionEnd: transitionEnd$1
	};

	function slideTo(index, speed, runCallbacks, internal) {
	  if (index === void 0) {
	    index = 0;
	  }

	  if (speed === void 0) {
	    speed = this.params.speed;
	  }

	  if (runCallbacks === void 0) {
	    runCallbacks = true;
	  }

	  if (typeof index !== 'number' && typeof index !== 'string') {
	    throw new Error("The 'index' argument cannot have type other than 'number' or 'string'. [" + typeof index + "] given.");
	  }

	  if (typeof index === 'string') {
	    /**
	     * The `index` argument converted from `string` to `number`.
	     * @type {number}
	     */
	    var indexAsNumber = parseInt(index, 10);
	    /**
	     * Determines whether the `index` argument is a valid `number`
	     * after being converted from the `string` type.
	     * @type {boolean}
	     */

	    var isValidNumber = isFinite(indexAsNumber);

	    if (!isValidNumber) {
	      throw new Error("The passed-in 'index' (string) couldn't be converted to 'number'. [" + index + "] given.");
	    } // Knowing that the converted `index` is a valid number,
	    // we can update the original argument's value.


	    index = indexAsNumber;
	  }

	  var swiper = this;
	  var slideIndex = index;
	  if (slideIndex < 0) slideIndex = 0;
	  var params = swiper.params,
	      snapGrid = swiper.snapGrid,
	      slidesGrid = swiper.slidesGrid,
	      previousIndex = swiper.previousIndex,
	      activeIndex = swiper.activeIndex,
	      rtl = swiper.rtlTranslate,
	      wrapperEl = swiper.wrapperEl;

	  if (swiper.animating && params.preventInteractionOnTransition) {
	    return false;
	  }

	  var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
	  var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
	  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

	  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
	    swiper.emit('beforeSlideChangeStart');
	  }

	  var translate = -snapGrid[snapIndex]; // Update progress

	  swiper.updateProgress(translate); // Normalize slideIndex

	  if (params.normalizeSlideIndex) {
	    for (var i = 0; i < slidesGrid.length; i += 1) {
	      if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {
	        slideIndex = i;
	      }
	    }
	  } // Directions locks


	  if (swiper.initialized && slideIndex !== activeIndex) {
	    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
	      return false;
	    }

	    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
	      if ((activeIndex || 0) !== slideIndex) return false;
	    }
	  }

	  var direction;
	  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index

	  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
	    swiper.updateActiveIndex(slideIndex); // Update Height

	    if (params.autoHeight) {
	      swiper.updateAutoHeight();
	    }

	    swiper.updateSlidesClasses();

	    if (params.effect !== 'slide') {
	      swiper.setTranslate(translate);
	    }

	    if (direction !== 'reset') {
	      swiper.transitionStart(runCallbacks, direction);
	      swiper.transitionEnd(runCallbacks, direction);
	    }

	    return false;
	  }

	  if (params.cssMode) {
	    var isH = swiper.isHorizontal();
	    var t = -translate;

	    if (rtl) {
	      t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;
	    }

	    if (speed === 0) {
	      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
	    } else {
	      // eslint-disable-next-line
	      if (wrapperEl.scrollTo) {
	        var _wrapperEl$scrollTo;

	        wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? 'left' : 'top'] = t, _wrapperEl$scrollTo.behavior = 'smooth', _wrapperEl$scrollTo));
	      } else {
	        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
	      }
	    }

	    return true;
	  }

	  if (speed === 0) {
	    swiper.setTransition(0);
	    swiper.setTranslate(translate);
	    swiper.updateActiveIndex(slideIndex);
	    swiper.updateSlidesClasses();
	    swiper.emit('beforeTransitionStart', speed, internal);
	    swiper.transitionStart(runCallbacks, direction);
	    swiper.transitionEnd(runCallbacks, direction);
	  } else {
	    swiper.setTransition(speed);
	    swiper.setTranslate(translate);
	    swiper.updateActiveIndex(slideIndex);
	    swiper.updateSlidesClasses();
	    swiper.emit('beforeTransitionStart', speed, internal);
	    swiper.transitionStart(runCallbacks, direction);

	    if (!swiper.animating) {
	      swiper.animating = true;

	      if (!swiper.onSlideToWrapperTransitionEnd) {
	        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
	          if (!swiper || swiper.destroyed) return;
	          if (e.target !== this) return;
	          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
	          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
	          swiper.onSlideToWrapperTransitionEnd = null;
	          delete swiper.onSlideToWrapperTransitionEnd;
	          swiper.transitionEnd(runCallbacks, direction);
	        };
	      }

	      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
	      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
	    }
	  }

	  return true;
	}

	function slideToLoop(index, speed, runCallbacks, internal) {
	  if (index === void 0) {
	    index = 0;
	  }

	  if (speed === void 0) {
	    speed = this.params.speed;
	  }

	  if (runCallbacks === void 0) {
	    runCallbacks = true;
	  }

	  var swiper = this;
	  var newIndex = index;

	  if (swiper.params.loop) {
	    newIndex += swiper.loopedSlides;
	  }

	  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
	}

	/* eslint no-unused-vars: "off" */
	function slideNext(speed, runCallbacks, internal) {
	  if (speed === void 0) {
	    speed = this.params.speed;
	  }

	  if (runCallbacks === void 0) {
	    runCallbacks = true;
	  }

	  var swiper = this;
	  var params = swiper.params,
	      animating = swiper.animating;
	  var increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;

	  if (params.loop) {
	    if (animating && params.loopPreventsSlide) return false;
	    swiper.loopFix(); // eslint-disable-next-line

	    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
	  }

	  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
	}

	/* eslint no-unused-vars: "off" */
	function slidePrev(speed, runCallbacks, internal) {
	  if (speed === void 0) {
	    speed = this.params.speed;
	  }

	  if (runCallbacks === void 0) {
	    runCallbacks = true;
	  }

	  var swiper = this;
	  var params = swiper.params,
	      animating = swiper.animating,
	      snapGrid = swiper.snapGrid,
	      slidesGrid = swiper.slidesGrid,
	      rtlTranslate = swiper.rtlTranslate;

	  if (params.loop) {
	    if (animating && params.loopPreventsSlide) return false;
	    swiper.loopFix(); // eslint-disable-next-line

	    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
	  }

	  var translate = rtlTranslate ? swiper.translate : -swiper.translate;

	  function normalize(val) {
	    if (val < 0) return -Math.floor(Math.abs(val));
	    return Math.floor(val);
	  }

	  var normalizedTranslate = normalize(translate);
	  var normalizedSnapGrid = snapGrid.map(function (val) {
	    return normalize(val);
	  });
	  var currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
	  var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];

	  if (typeof prevSnap === 'undefined' && params.cssMode) {
	    snapGrid.forEach(function (snap) {
	      if (!prevSnap && normalizedTranslate >= snap) prevSnap = snap;
	    });
	  }

	  var prevIndex;

	  if (typeof prevSnap !== 'undefined') {
	    prevIndex = slidesGrid.indexOf(prevSnap);
	    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
	  }

	  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
	}

	/* eslint no-unused-vars: "off" */
	function slideReset(speed, runCallbacks, internal) {
	  if (speed === void 0) {
	    speed = this.params.speed;
	  }

	  if (runCallbacks === void 0) {
	    runCallbacks = true;
	  }

	  var swiper = this;
	  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
	}

	/* eslint no-unused-vars: "off" */
	function slideToClosest(speed, runCallbacks, internal, threshold) {
	  if (speed === void 0) {
	    speed = this.params.speed;
	  }

	  if (runCallbacks === void 0) {
	    runCallbacks = true;
	  }

	  if (threshold === void 0) {
	    threshold = 0.5;
	  }

	  var swiper = this;
	  var index = swiper.activeIndex;
	  var skip = Math.min(swiper.params.slidesPerGroupSkip, index);
	  var snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
	  var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

	  if (translate >= swiper.snapGrid[snapIndex]) {
	    // The current translate is on or after the current snap index, so the choice
	    // is between the current index and the one after it.
	    var currentSnap = swiper.snapGrid[snapIndex];
	    var nextSnap = swiper.snapGrid[snapIndex + 1];

	    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
	      index += swiper.params.slidesPerGroup;
	    }
	  } else {
	    // The current translate is before the current snap index, so the choice
	    // is between the current index and the one before it.
	    var prevSnap = swiper.snapGrid[snapIndex - 1];
	    var _currentSnap = swiper.snapGrid[snapIndex];

	    if (translate - prevSnap <= (_currentSnap - prevSnap) * threshold) {
	      index -= swiper.params.slidesPerGroup;
	    }
	  }

	  index = Math.max(index, 0);
	  index = Math.min(index, swiper.slidesGrid.length - 1);
	  return swiper.slideTo(index, speed, runCallbacks, internal);
	}

	function slideToClickedSlide() {
	  var swiper = this;
	  var params = swiper.params,
	      $wrapperEl = swiper.$wrapperEl;
	  var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
	  var slideToIndex = swiper.clickedIndex;
	  var realIndex;

	  if (params.loop) {
	    if (swiper.animating) return;
	    realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);

	    if (params.centeredSlides) {
	      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
	        swiper.loopFix();
	        slideToIndex = $wrapperEl.children("." + params.slideClass + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + params.slideDuplicateClass + ")").eq(0).index();
	        nextTick(function () {
	          swiper.slideTo(slideToIndex);
	        });
	      } else {
	        swiper.slideTo(slideToIndex);
	      }
	    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
	      swiper.loopFix();
	      slideToIndex = $wrapperEl.children("." + params.slideClass + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + params.slideDuplicateClass + ")").eq(0).index();
	      nextTick(function () {
	        swiper.slideTo(slideToIndex);
	      });
	    } else {
	      swiper.slideTo(slideToIndex);
	    }
	  } else {
	    swiper.slideTo(slideToIndex);
	  }
	}

	var slide = {
	  slideTo: slideTo,
	  slideToLoop: slideToLoop,
	  slideNext: slideNext,
	  slidePrev: slidePrev,
	  slideReset: slideReset,
	  slideToClosest: slideToClosest,
	  slideToClickedSlide: slideToClickedSlide
	};

	function loopCreate() {
	  var swiper = this;
	  var document = getDocument();
	  var params = swiper.params,
	      $wrapperEl = swiper.$wrapperEl; // Remove duplicated slides

	  $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass).remove();
	  var slides = $wrapperEl.children("." + params.slideClass);

	  if (params.loopFillGroupWithBlank) {
	    var blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;

	    if (blankSlidesNum !== params.slidesPerGroup) {
	      for (var i = 0; i < blankSlidesNum; i += 1) {
	        var blankNode = $(document.createElement('div')).addClass(params.slideClass + " " + params.slideBlankClass);
	        $wrapperEl.append(blankNode);
	      }

	      slides = $wrapperEl.children("." + params.slideClass);
	    }
	  }

	  if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
	  swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
	  swiper.loopedSlides += params.loopAdditionalSlides;

	  if (swiper.loopedSlides > slides.length) {
	    swiper.loopedSlides = slides.length;
	  }

	  var prependSlides = [];
	  var appendSlides = [];
	  slides.each(function (el, index) {
	    var slide = $(el);

	    if (index < swiper.loopedSlides) {
	      appendSlides.push(el);
	    }

	    if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
	      prependSlides.push(el);
	    }

	    slide.attr('data-swiper-slide-index', index);
	  });

	  for (var _i = 0; _i < appendSlides.length; _i += 1) {
	    $wrapperEl.append($(appendSlides[_i].cloneNode(true)).addClass(params.slideDuplicateClass));
	  }

	  for (var _i2 = prependSlides.length - 1; _i2 >= 0; _i2 -= 1) {
	    $wrapperEl.prepend($(prependSlides[_i2].cloneNode(true)).addClass(params.slideDuplicateClass));
	  }
	}

	function loopFix() {
	  var swiper = this;
	  swiper.emit('beforeLoopFix');
	  var activeIndex = swiper.activeIndex,
	      slides = swiper.slides,
	      loopedSlides = swiper.loopedSlides,
	      allowSlidePrev = swiper.allowSlidePrev,
	      allowSlideNext = swiper.allowSlideNext,
	      snapGrid = swiper.snapGrid,
	      rtl = swiper.rtlTranslate;
	  var newIndex;
	  swiper.allowSlidePrev = true;
	  swiper.allowSlideNext = true;
	  var snapTranslate = -snapGrid[activeIndex];
	  var diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

	  if (activeIndex < loopedSlides) {
	    newIndex = slides.length - loopedSlides * 3 + activeIndex;
	    newIndex += loopedSlides;
	    var slideChanged = swiper.slideTo(newIndex, 0, false, true);

	    if (slideChanged && diff !== 0) {
	      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
	    }
	  } else if (activeIndex >= slides.length - loopedSlides) {
	    // Fix For Positive Oversliding
	    newIndex = -slides.length + activeIndex + loopedSlides;
	    newIndex += loopedSlides;

	    var _slideChanged = swiper.slideTo(newIndex, 0, false, true);

	    if (_slideChanged && diff !== 0) {
	      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
	    }
	  }

	  swiper.allowSlidePrev = allowSlidePrev;
	  swiper.allowSlideNext = allowSlideNext;
	  swiper.emit('loopFix');
	}

	function loopDestroy() {
	  var swiper = this;
	  var $wrapperEl = swiper.$wrapperEl,
	      params = swiper.params,
	      slides = swiper.slides;
	  $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + ",." + params.slideClass + "." + params.slideBlankClass).remove();
	  slides.removeAttr('data-swiper-slide-index');
	}

	var loop = {
	  loopCreate: loopCreate,
	  loopFix: loopFix,
	  loopDestroy: loopDestroy
	};

	function setGrabCursor(moving) {
	  var swiper = this;
	  if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
	  var el = swiper.el;
	  el.style.cursor = 'move';
	  el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
	  el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
	  el.style.cursor = moving ? 'grabbing' : 'grab';
	}

	function unsetGrabCursor() {
	  var swiper = this;

	  if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
	    return;
	  }

	  swiper.el.style.cursor = '';
	}

	var grabCursor = {
	  setGrabCursor: setGrabCursor,
	  unsetGrabCursor: unsetGrabCursor
	};

	function appendSlide(slides) {
	  var swiper = this;
	  var $wrapperEl = swiper.$wrapperEl,
	      params = swiper.params;

	  if (params.loop) {
	    swiper.loopDestroy();
	  }

	  if (typeof slides === 'object' && 'length' in slides) {
	    for (var i = 0; i < slides.length; i += 1) {
	      if (slides[i]) $wrapperEl.append(slides[i]);
	    }
	  } else {
	    $wrapperEl.append(slides);
	  }

	  if (params.loop) {
	    swiper.loopCreate();
	  }

	  if (!(params.observer && swiper.support.observer)) {
	    swiper.update();
	  }
	}

	function prependSlide(slides) {
	  var swiper = this;
	  var params = swiper.params,
	      $wrapperEl = swiper.$wrapperEl,
	      activeIndex = swiper.activeIndex;

	  if (params.loop) {
	    swiper.loopDestroy();
	  }

	  var newActiveIndex = activeIndex + 1;

	  if (typeof slides === 'object' && 'length' in slides) {
	    for (var i = 0; i < slides.length; i += 1) {
	      if (slides[i]) $wrapperEl.prepend(slides[i]);
	    }

	    newActiveIndex = activeIndex + slides.length;
	  } else {
	    $wrapperEl.prepend(slides);
	  }

	  if (params.loop) {
	    swiper.loopCreate();
	  }

	  if (!(params.observer && swiper.support.observer)) {
	    swiper.update();
	  }

	  swiper.slideTo(newActiveIndex, 0, false);
	}

	function addSlide(index, slides) {
	  var swiper = this;
	  var $wrapperEl = swiper.$wrapperEl,
	      params = swiper.params,
	      activeIndex = swiper.activeIndex;
	  var activeIndexBuffer = activeIndex;

	  if (params.loop) {
	    activeIndexBuffer -= swiper.loopedSlides;
	    swiper.loopDestroy();
	    swiper.slides = $wrapperEl.children("." + params.slideClass);
	  }

	  var baseLength = swiper.slides.length;

	  if (index <= 0) {
	    swiper.prependSlide(slides);
	    return;
	  }

	  if (index >= baseLength) {
	    swiper.appendSlide(slides);
	    return;
	  }

	  var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
	  var slidesBuffer = [];

	  for (var i = baseLength - 1; i >= index; i -= 1) {
	    var currentSlide = swiper.slides.eq(i);
	    currentSlide.remove();
	    slidesBuffer.unshift(currentSlide);
	  }

	  if (typeof slides === 'object' && 'length' in slides) {
	    for (var _i = 0; _i < slides.length; _i += 1) {
	      if (slides[_i]) $wrapperEl.append(slides[_i]);
	    }

	    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
	  } else {
	    $wrapperEl.append(slides);
	  }

	  for (var _i2 = 0; _i2 < slidesBuffer.length; _i2 += 1) {
	    $wrapperEl.append(slidesBuffer[_i2]);
	  }

	  if (params.loop) {
	    swiper.loopCreate();
	  }

	  if (!(params.observer && swiper.support.observer)) {
	    swiper.update();
	  }

	  if (params.loop) {
	    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
	  } else {
	    swiper.slideTo(newActiveIndex, 0, false);
	  }
	}

	function removeSlide(slidesIndexes) {
	  var swiper = this;
	  var params = swiper.params,
	      $wrapperEl = swiper.$wrapperEl,
	      activeIndex = swiper.activeIndex;
	  var activeIndexBuffer = activeIndex;

	  if (params.loop) {
	    activeIndexBuffer -= swiper.loopedSlides;
	    swiper.loopDestroy();
	    swiper.slides = $wrapperEl.children("." + params.slideClass);
	  }

	  var newActiveIndex = activeIndexBuffer;
	  var indexToRemove;

	  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
	    for (var i = 0; i < slidesIndexes.length; i += 1) {
	      indexToRemove = slidesIndexes[i];
	      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
	      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
	    }

	    newActiveIndex = Math.max(newActiveIndex, 0);
	  } else {
	    indexToRemove = slidesIndexes;
	    if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
	    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
	    newActiveIndex = Math.max(newActiveIndex, 0);
	  }

	  if (params.loop) {
	    swiper.loopCreate();
	  }

	  if (!(params.observer && swiper.support.observer)) {
	    swiper.update();
	  }

	  if (params.loop) {
	    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
	  } else {
	    swiper.slideTo(newActiveIndex, 0, false);
	  }
	}

	function removeAllSlides() {
	  var swiper = this;
	  var slidesIndexes = [];

	  for (var i = 0; i < swiper.slides.length; i += 1) {
	    slidesIndexes.push(i);
	  }

	  swiper.removeSlide(slidesIndexes);
	}

	var manipulation = {
	  appendSlide: appendSlide,
	  prependSlide: prependSlide,
	  addSlide: addSlide,
	  removeSlide: removeSlide,
	  removeAllSlides: removeAllSlides
	};

	function onTouchStart(event) {
	  var swiper = this;
	  var document = getDocument();
	  var window = getWindow();
	  var data = swiper.touchEventsData;
	  var params = swiper.params,
	      touches = swiper.touches;

	  if (swiper.animating && params.preventInteractionOnTransition) {
	    return;
	  }

	  var e = event;
	  if (e.originalEvent) e = e.originalEvent;
	  var $targetEl = $(e.target);

	  if (params.touchEventsTarget === 'wrapper') {
	    if (!$targetEl.closest(swiper.wrapperEl).length) return;
	  }

	  data.isTouchEvent = e.type === 'touchstart';
	  if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
	  if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
	  if (data.isTouched && data.isMoved) return; // change target el for shadow root componenet

	  var swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';

	  if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {
	    $targetEl = $(event.path[0]);
	  }

	  if (params.noSwiping && $targetEl.closest(params.noSwipingSelector ? params.noSwipingSelector : "." + params.noSwipingClass)[0]) {
	    swiper.allowClick = true;
	    return;
	  }

	  if (params.swipeHandler) {
	    if (!$targetEl.closest(params.swipeHandler)[0]) return;
	  }

	  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	  var startX = touches.currentX;
	  var startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

	  var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
	  var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;

	  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
	    return;
	  }

	  extend$1(data, {
	    isTouched: true,
	    isMoved: false,
	    allowTouchCallbacks: true,
	    isScrolling: undefined,
	    startMoving: undefined
	  });
	  touches.startX = startX;
	  touches.startY = startY;
	  data.touchStartTime = now();
	  swiper.allowClick = true;
	  swiper.updateSize();
	  swiper.swipeDirection = undefined;
	  if (params.threshold > 0) data.allowThresholdMove = false;

	  if (e.type !== 'touchstart') {
	    var preventDefault = true;
	    if ($targetEl.is(data.formElements)) preventDefault = false;

	    if (document.activeElement && $(document.activeElement).is(data.formElements) && document.activeElement !== $targetEl[0]) {
	      document.activeElement.blur();
	    }

	    var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;

	    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
	      e.preventDefault();
	    }
	  }

	  swiper.emit('touchStart', e);
	}

	function onTouchMove(event) {
	  var document = getDocument();
	  var swiper = this;
	  var data = swiper.touchEventsData;
	  var params = swiper.params,
	      touches = swiper.touches,
	      rtl = swiper.rtlTranslate;
	  var e = event;
	  if (e.originalEvent) e = e.originalEvent;

	  if (!data.isTouched) {
	    if (data.startMoving && data.isScrolling) {
	      swiper.emit('touchMoveOpposite', e);
	    }

	    return;
	  }

	  if (data.isTouchEvent && e.type !== 'touchmove') return;
	  var targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
	  var pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
	  var pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;

	  if (e.preventedByNestedSwiper) {
	    touches.startX = pageX;
	    touches.startY = pageY;
	    return;
	  }

	  if (!swiper.allowTouchMove) {
	    // isMoved = true;
	    swiper.allowClick = false;

	    if (data.isTouched) {
	      extend$1(touches, {
	        startX: pageX,
	        startY: pageY,
	        currentX: pageX,
	        currentY: pageY
	      });
	      data.touchStartTime = now();
	    }

	    return;
	  }

	  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
	    if (swiper.isVertical()) {
	      // Vertical
	      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
	        data.isTouched = false;
	        data.isMoved = false;
	        return;
	      }
	    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
	      return;
	    }
	  }

	  if (data.isTouchEvent && document.activeElement) {
	    if (e.target === document.activeElement && $(e.target).is(data.formElements)) {
	      data.isMoved = true;
	      swiper.allowClick = false;
	      return;
	    }
	  }

	  if (data.allowTouchCallbacks) {
	    swiper.emit('touchMove', e);
	  }

	  if (e.targetTouches && e.targetTouches.length > 1) return;
	  touches.currentX = pageX;
	  touches.currentY = pageY;
	  var diffX = touches.currentX - touches.startX;
	  var diffY = touches.currentY - touches.startY;
	  if (swiper.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < swiper.params.threshold) return;

	  if (typeof data.isScrolling === 'undefined') {
	    var touchAngle;

	    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
	      data.isScrolling = false;
	    } else {
	      // eslint-disable-next-line
	      if (diffX * diffX + diffY * diffY >= 25) {
	        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
	        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
	      }
	    }
	  }

	  if (data.isScrolling) {
	    swiper.emit('touchMoveOpposite', e);
	  }

	  if (typeof data.startMoving === 'undefined') {
	    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
	      data.startMoving = true;
	    }
	  }

	  if (data.isScrolling) {
	    data.isTouched = false;
	    return;
	  }

	  if (!data.startMoving) {
	    return;
	  }

	  swiper.allowClick = false;

	  if (!params.cssMode && e.cancelable) {
	    e.preventDefault();
	  }

	  if (params.touchMoveStopPropagation && !params.nested) {
	    e.stopPropagation();
	  }

	  if (!data.isMoved) {
	    if (params.loop) {
	      swiper.loopFix();
	    }

	    data.startTranslate = swiper.getTranslate();
	    swiper.setTransition(0);

	    if (swiper.animating) {
	      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
	    }

	    data.allowMomentumBounce = false; // Grab Cursor

	    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
	      swiper.setGrabCursor(true);
	    }

	    swiper.emit('sliderFirstMove', e);
	  }

	  swiper.emit('sliderMove', e);
	  data.isMoved = true;
	  var diff = swiper.isHorizontal() ? diffX : diffY;
	  touches.diff = diff;
	  diff *= params.touchRatio;
	  if (rtl) diff = -diff;
	  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
	  data.currentTranslate = diff + data.startTranslate;
	  var disableParentSwiper = true;
	  var resistanceRatio = params.resistanceRatio;

	  if (params.touchReleaseOnEdges) {
	    resistanceRatio = 0;
	  }

	  if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
	    disableParentSwiper = false;
	    if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + Math.pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);
	  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
	    disableParentSwiper = false;
	    if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - Math.pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);
	  }

	  if (disableParentSwiper) {
	    e.preventedByNestedSwiper = true;
	  } // Directions locks


	  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
	    data.currentTranslate = data.startTranslate;
	  }

	  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
	    data.currentTranslate = data.startTranslate;
	  } // Threshold


	  if (params.threshold > 0) {
	    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
	      if (!data.allowThresholdMove) {
	        data.allowThresholdMove = true;
	        touches.startX = touches.currentX;
	        touches.startY = touches.currentY;
	        data.currentTranslate = data.startTranslate;
	        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
	        return;
	      }
	    } else {
	      data.currentTranslate = data.startTranslate;
	      return;
	    }
	  }

	  if (!params.followFinger || params.cssMode) return; // Update active index in free mode

	  if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
	    swiper.updateActiveIndex();
	    swiper.updateSlidesClasses();
	  }

	  if (params.freeMode) {
	    // Velocity
	    if (data.velocities.length === 0) {
	      data.velocities.push({
	        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
	        time: data.touchStartTime
	      });
	    }

	    data.velocities.push({
	      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
	      time: now()
	    });
	  } // Update progress


	  swiper.updateProgress(data.currentTranslate); // Update translate

	  swiper.setTranslate(data.currentTranslate);
	}

	function onTouchEnd(event) {
	  var swiper = this;
	  var data = swiper.touchEventsData;
	  var params = swiper.params,
	      touches = swiper.touches,
	      rtl = swiper.rtlTranslate,
	      $wrapperEl = swiper.$wrapperEl,
	      slidesGrid = swiper.slidesGrid,
	      snapGrid = swiper.snapGrid;
	  var e = event;
	  if (e.originalEvent) e = e.originalEvent;

	  if (data.allowTouchCallbacks) {
	    swiper.emit('touchEnd', e);
	  }

	  data.allowTouchCallbacks = false;

	  if (!data.isTouched) {
	    if (data.isMoved && params.grabCursor) {
	      swiper.setGrabCursor(false);
	    }

	    data.isMoved = false;
	    data.startMoving = false;
	    return;
	  } // Return Grab Cursor


	  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
	    swiper.setGrabCursor(false);
	  } // Time diff


	  var touchEndTime = now();
	  var timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

	  if (swiper.allowClick) {
	    swiper.updateClickedSlide(e);
	    swiper.emit('tap click', e);

	    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
	      swiper.emit('doubleTap doubleClick', e);
	    }
	  }

	  data.lastClickTime = now();
	  nextTick(function () {
	    if (!swiper.destroyed) swiper.allowClick = true;
	  });

	  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
	    data.isTouched = false;
	    data.isMoved = false;
	    data.startMoving = false;
	    return;
	  }

	  data.isTouched = false;
	  data.isMoved = false;
	  data.startMoving = false;
	  var currentPos;

	  if (params.followFinger) {
	    currentPos = rtl ? swiper.translate : -swiper.translate;
	  } else {
	    currentPos = -data.currentTranslate;
	  }

	  if (params.cssMode) {
	    return;
	  }

	  if (params.freeMode) {
	    if (currentPos < -swiper.minTranslate()) {
	      swiper.slideTo(swiper.activeIndex);
	      return;
	    }

	    if (currentPos > -swiper.maxTranslate()) {
	      if (swiper.slides.length < snapGrid.length) {
	        swiper.slideTo(snapGrid.length - 1);
	      } else {
	        swiper.slideTo(swiper.slides.length - 1);
	      }

	      return;
	    }

	    if (params.freeModeMomentum) {
	      if (data.velocities.length > 1) {
	        var lastMoveEvent = data.velocities.pop();
	        var velocityEvent = data.velocities.pop();
	        var distance = lastMoveEvent.position - velocityEvent.position;
	        var time = lastMoveEvent.time - velocityEvent.time;
	        swiper.velocity = distance / time;
	        swiper.velocity /= 2;

	        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
	          swiper.velocity = 0;
	        } // this implies that the user stopped moving a finger then released.
	        // There would be no events with distance zero, so the last event is stale.


	        if (time > 150 || now() - lastMoveEvent.time > 300) {
	          swiper.velocity = 0;
	        }
	      } else {
	        swiper.velocity = 0;
	      }

	      swiper.velocity *= params.freeModeMomentumVelocityRatio;
	      data.velocities.length = 0;
	      var momentumDuration = 1000 * params.freeModeMomentumRatio;
	      var momentumDistance = swiper.velocity * momentumDuration;
	      var newPosition = swiper.translate + momentumDistance;
	      if (rtl) newPosition = -newPosition;
	      var doBounce = false;
	      var afterBouncePosition;
	      var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
	      var needsLoopFix;

	      if (newPosition < swiper.maxTranslate()) {
	        if (params.freeModeMomentumBounce) {
	          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
	            newPosition = swiper.maxTranslate() - bounceAmount;
	          }

	          afterBouncePosition = swiper.maxTranslate();
	          doBounce = true;
	          data.allowMomentumBounce = true;
	        } else {
	          newPosition = swiper.maxTranslate();
	        }

	        if (params.loop && params.centeredSlides) needsLoopFix = true;
	      } else if (newPosition > swiper.minTranslate()) {
	        if (params.freeModeMomentumBounce) {
	          if (newPosition - swiper.minTranslate() > bounceAmount) {
	            newPosition = swiper.minTranslate() + bounceAmount;
	          }

	          afterBouncePosition = swiper.minTranslate();
	          doBounce = true;
	          data.allowMomentumBounce = true;
	        } else {
	          newPosition = swiper.minTranslate();
	        }

	        if (params.loop && params.centeredSlides) needsLoopFix = true;
	      } else if (params.freeModeSticky) {
	        var nextSlide;

	        for (var j = 0; j < snapGrid.length; j += 1) {
	          if (snapGrid[j] > -newPosition) {
	            nextSlide = j;
	            break;
	          }
	        }

	        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
	          newPosition = snapGrid[nextSlide];
	        } else {
	          newPosition = snapGrid[nextSlide - 1];
	        }

	        newPosition = -newPosition;
	      }

	      if (needsLoopFix) {
	        swiper.once('transitionEnd', function () {
	          swiper.loopFix();
	        });
	      } // Fix duration


	      if (swiper.velocity !== 0) {
	        if (rtl) {
	          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
	        } else {
	          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
	        }

	        if (params.freeModeSticky) {
	          // If freeModeSticky is active and the user ends a swipe with a slow-velocity
	          // event, then durations can be 20+ seconds to slide one (or zero!) slides.
	          // It's easy to see this when simulating touch with mouse events. To fix this,
	          // limit single-slide swipes to the default slide duration. This also has the
	          // nice side effect of matching slide speed if the user stopped moving before
	          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
	          // For faster swipes, also apply limits (albeit higher ones).
	          var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
	          var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];

	          if (moveDistance < currentSlideSize) {
	            momentumDuration = params.speed;
	          } else if (moveDistance < 2 * currentSlideSize) {
	            momentumDuration = params.speed * 1.5;
	          } else {
	            momentumDuration = params.speed * 2.5;
	          }
	        }
	      } else if (params.freeModeSticky) {
	        swiper.slideToClosest();
	        return;
	      }

	      if (params.freeModeMomentumBounce && doBounce) {
	        swiper.updateProgress(afterBouncePosition);
	        swiper.setTransition(momentumDuration);
	        swiper.setTranslate(newPosition);
	        swiper.transitionStart(true, swiper.swipeDirection);
	        swiper.animating = true;
	        $wrapperEl.transitionEnd(function () {
	          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
	          swiper.emit('momentumBounce');
	          swiper.setTransition(params.speed);
	          setTimeout(function () {
	            swiper.setTranslate(afterBouncePosition);
	            $wrapperEl.transitionEnd(function () {
	              if (!swiper || swiper.destroyed) return;
	              swiper.transitionEnd();
	            });
	          }, 0);
	        });
	      } else if (swiper.velocity) {
	        swiper.updateProgress(newPosition);
	        swiper.setTransition(momentumDuration);
	        swiper.setTranslate(newPosition);
	        swiper.transitionStart(true, swiper.swipeDirection);

	        if (!swiper.animating) {
	          swiper.animating = true;
	          $wrapperEl.transitionEnd(function () {
	            if (!swiper || swiper.destroyed) return;
	            swiper.transitionEnd();
	          });
	        }
	      } else {
	        swiper.updateProgress(newPosition);
	      }

	      swiper.updateActiveIndex();
	      swiper.updateSlidesClasses();
	    } else if (params.freeModeSticky) {
	      swiper.slideToClosest();
	      return;
	    }

	    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
	      swiper.updateProgress();
	      swiper.updateActiveIndex();
	      swiper.updateSlidesClasses();
	    }

	    return;
	  } // Find current slide


	  var stopIndex = 0;
	  var groupSize = swiper.slidesSizesGrid[0];

	  for (var i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
	    var _increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

	    if (typeof slidesGrid[i + _increment] !== 'undefined') {
	      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + _increment]) {
	        stopIndex = i;
	        groupSize = slidesGrid[i + _increment] - slidesGrid[i];
	      }
	    } else if (currentPos >= slidesGrid[i]) {
	      stopIndex = i;
	      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
	    }
	  } // Find current slide size


	  var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
	  var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

	  if (timeDiff > params.longSwipesMs) {
	    // Long touches
	    if (!params.longSwipes) {
	      swiper.slideTo(swiper.activeIndex);
	      return;
	    }

	    if (swiper.swipeDirection === 'next') {
	      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
	    }

	    if (swiper.swipeDirection === 'prev') {
	      if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
	    }
	  } else {
	    // Short swipes
	    if (!params.shortSwipes) {
	      swiper.slideTo(swiper.activeIndex);
	      return;
	    }

	    var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);

	    if (!isNavButtonTarget) {
	      if (swiper.swipeDirection === 'next') {
	        swiper.slideTo(stopIndex + increment);
	      }

	      if (swiper.swipeDirection === 'prev') {
	        swiper.slideTo(stopIndex);
	      }
	    } else if (e.target === swiper.navigation.nextEl) {
	      swiper.slideTo(stopIndex + increment);
	    } else {
	      swiper.slideTo(stopIndex);
	    }
	  }
	}

	function onResize() {
	  var swiper = this;
	  var params = swiper.params,
	      el = swiper.el;
	  if (el && el.offsetWidth === 0) return; // Breakpoints

	  if (params.breakpoints) {
	    swiper.setBreakpoint();
	  } // Save locks


	  var allowSlideNext = swiper.allowSlideNext,
	      allowSlidePrev = swiper.allowSlidePrev,
	      snapGrid = swiper.snapGrid; // Disable locks on resize

	  swiper.allowSlideNext = true;
	  swiper.allowSlidePrev = true;
	  swiper.updateSize();
	  swiper.updateSlides();
	  swiper.updateSlidesClasses();

	  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
	    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
	  } else {
	    swiper.slideTo(swiper.activeIndex, 0, false, true);
	  }

	  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
	    swiper.autoplay.run();
	  } // Return locks after resize


	  swiper.allowSlidePrev = allowSlidePrev;
	  swiper.allowSlideNext = allowSlideNext;

	  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
	    swiper.checkOverflow();
	  }
	}

	function onClick(e) {
	  var swiper = this;

	  if (!swiper.allowClick) {
	    if (swiper.params.preventClicks) e.preventDefault();

	    if (swiper.params.preventClicksPropagation && swiper.animating) {
	      e.stopPropagation();
	      e.stopImmediatePropagation();
	    }
	  }
	}

	function onScroll() {
	  var swiper = this;
	  var wrapperEl = swiper.wrapperEl,
	      rtlTranslate = swiper.rtlTranslate;
	  swiper.previousTranslate = swiper.translate;

	  if (swiper.isHorizontal()) {
	    if (rtlTranslate) {
	      swiper.translate = wrapperEl.scrollWidth - wrapperEl.offsetWidth - wrapperEl.scrollLeft;
	    } else {
	      swiper.translate = -wrapperEl.scrollLeft;
	    }
	  } else {
	    swiper.translate = -wrapperEl.scrollTop;
	  } // eslint-disable-next-line


	  if (swiper.translate === -0) swiper.translate = 0;
	  swiper.updateActiveIndex();
	  swiper.updateSlidesClasses();
	  var newProgress;
	  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

	  if (translatesDiff === 0) {
	    newProgress = 0;
	  } else {
	    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
	  }

	  if (newProgress !== swiper.progress) {
	    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
	  }

	  swiper.emit('setTranslate', swiper.translate, false);
	}

	var dummyEventAttached = false;

	function dummyEventListener() {}

	function attachEvents() {
	  var swiper = this;
	  var document = getDocument();
	  var params = swiper.params,
	      touchEvents = swiper.touchEvents,
	      el = swiper.el,
	      wrapperEl = swiper.wrapperEl,
	      device = swiper.device,
	      support = swiper.support;
	  swiper.onTouchStart = onTouchStart.bind(swiper);
	  swiper.onTouchMove = onTouchMove.bind(swiper);
	  swiper.onTouchEnd = onTouchEnd.bind(swiper);

	  if (params.cssMode) {
	    swiper.onScroll = onScroll.bind(swiper);
	  }

	  swiper.onClick = onClick.bind(swiper);
	  var capture = !!params.nested; // Touch Events

	  if (!support.touch && support.pointerEvents) {
	    el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
	    document.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
	    document.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
	  } else {
	    if (support.touch) {
	      var passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
	        passive: true,
	        capture: false
	      } : false;
	      el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
	      el.addEventListener(touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
	        passive: false,
	        capture: capture
	      } : capture);
	      el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

	      if (touchEvents.cancel) {
	        el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
	      }

	      if (!dummyEventAttached) {
	        document.addEventListener('touchstart', dummyEventListener);
	        dummyEventAttached = true;
	      }
	    }

	    if (params.simulateTouch && !device.ios && !device.android || params.simulateTouch && !support.touch && device.ios) {
	      el.addEventListener('mousedown', swiper.onTouchStart, false);
	      document.addEventListener('mousemove', swiper.onTouchMove, capture);
	      document.addEventListener('mouseup', swiper.onTouchEnd, false);
	    }
	  } // Prevent Links Clicks


	  if (params.preventClicks || params.preventClicksPropagation) {
	    el.addEventListener('click', swiper.onClick, true);
	  }

	  if (params.cssMode) {
	    wrapperEl.addEventListener('scroll', swiper.onScroll);
	  } // Resize handler


	  if (params.updateOnWindowResize) {
	    swiper.on(device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
	  } else {
	    swiper.on('observerUpdate', onResize, true);
	  }
	}

	function detachEvents() {
	  var swiper = this;
	  var document = getDocument();
	  var params = swiper.params,
	      touchEvents = swiper.touchEvents,
	      el = swiper.el,
	      wrapperEl = swiper.wrapperEl,
	      device = swiper.device,
	      support = swiper.support;
	  var capture = !!params.nested; // Touch Events

	  if (!support.touch && support.pointerEvents) {
	    el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
	    document.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
	    document.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
	  } else {
	    if (support.touch) {
	      var passiveListener = touchEvents.start === 'onTouchStart' && support.passiveListener && params.passiveListeners ? {
	        passive: true,
	        capture: false
	      } : false;
	      el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
	      el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
	      el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

	      if (touchEvents.cancel) {
	        el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
	      }
	    }

	    if (params.simulateTouch && !device.ios && !device.android || params.simulateTouch && !support.touch && device.ios) {
	      el.removeEventListener('mousedown', swiper.onTouchStart, false);
	      document.removeEventListener('mousemove', swiper.onTouchMove, capture);
	      document.removeEventListener('mouseup', swiper.onTouchEnd, false);
	    }
	  } // Prevent Links Clicks


	  if (params.preventClicks || params.preventClicksPropagation) {
	    el.removeEventListener('click', swiper.onClick, true);
	  }

	  if (params.cssMode) {
	    wrapperEl.removeEventListener('scroll', swiper.onScroll);
	  } // Resize handler


	  swiper.off(device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize);
	}

	var events = {
	  attachEvents: attachEvents,
	  detachEvents: detachEvents
	};

	function setBreakpoint() {
	  var swiper = this;
	  var activeIndex = swiper.activeIndex,
	      initialized = swiper.initialized,
	      _swiper$loopedSlides = swiper.loopedSlides,
	      loopedSlides = _swiper$loopedSlides === void 0 ? 0 : _swiper$loopedSlides,
	      params = swiper.params,
	      $el = swiper.$el;
	  var breakpoints = params.breakpoints;
	  if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; // Get breakpoint for window width and update parameters

	  var breakpoint = swiper.getBreakpoint(breakpoints);

	  if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
	    var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;

	    if (breakpointOnlyParams) {
	      ['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerGroupSkip', 'slidesPerColumn'].forEach(function (param) {
	        var paramValue = breakpointOnlyParams[param];
	        if (typeof paramValue === 'undefined') return;

	        if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
	          breakpointOnlyParams[param] = 'auto';
	        } else if (param === 'slidesPerView') {
	          breakpointOnlyParams[param] = parseFloat(paramValue);
	        } else {
	          breakpointOnlyParams[param] = parseInt(paramValue, 10);
	        }
	      });
	    }

	    var breakpointParams = breakpointOnlyParams || swiper.originalParams;
	    var wasMultiRow = params.slidesPerColumn > 1;
	    var isMultiRow = breakpointParams.slidesPerColumn > 1;

	    if (wasMultiRow && !isMultiRow) {
	      $el.removeClass(params.containerModifierClass + "multirow " + params.containerModifierClass + "multirow-column");
	      swiper.emitContainerClasses();
	    } else if (!wasMultiRow && isMultiRow) {
	      $el.addClass(params.containerModifierClass + "multirow");

	      if (breakpointParams.slidesPerColumnFill === 'column') {
	        $el.addClass(params.containerModifierClass + "multirow-column");
	      }

	      swiper.emitContainerClasses();
	    }

	    var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
	    var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

	    if (directionChanged && initialized) {
	      swiper.changeDirection();
	    }

	    extend$1(swiper.params, breakpointParams);
	    extend$1(swiper, {
	      allowTouchMove: swiper.params.allowTouchMove,
	      allowSlideNext: swiper.params.allowSlideNext,
	      allowSlidePrev: swiper.params.allowSlidePrev
	    });
	    swiper.currentBreakpoint = breakpoint;
	    swiper.emit('_beforeBreakpoint', breakpointParams);

	    if (needsReLoop && initialized) {
	      swiper.loopDestroy();
	      swiper.loopCreate();
	      swiper.updateSlides();
	      swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
	    }

	    swiper.emit('breakpoint', breakpointParams);
	  }
	}

	function getBreakpoints(breakpoints) {
	  var window = getWindow(); // Get breakpoint for window width

	  if (!breakpoints) return undefined;
	  var breakpoint = false;
	  var points = Object.keys(breakpoints).map(function (point) {
	    if (typeof point === 'string' && point.indexOf('@') === 0) {
	      var minRatio = parseFloat(point.substr(1));
	      var value = window.innerHeight * minRatio;
	      return {
	        value: value,
	        point: point
	      };
	    }

	    return {
	      value: point,
	      point: point
	    };
	  });
	  points.sort(function (a, b) {
	    return parseInt(a.value, 10) - parseInt(b.value, 10);
	  });

	  for (var i = 0; i < points.length; i += 1) {
	    var _points$i = points[i],
	        point = _points$i.point,
	        value = _points$i.value;

	    if (value <= window.innerWidth) {
	      breakpoint = point;
	    }
	  }

	  return breakpoint || 'max';
	}

	var breakpoints = {
	  setBreakpoint: setBreakpoint,
	  getBreakpoint: getBreakpoints
	};

	function addClasses() {
	  var swiper = this;
	  var classNames = swiper.classNames,
	      params = swiper.params,
	      rtl = swiper.rtl,
	      $el = swiper.$el,
	      device = swiper.device;
	  var suffixes = [];
	  suffixes.push('initialized');
	  suffixes.push(params.direction);

	  if (params.freeMode) {
	    suffixes.push('free-mode');
	  }

	  if (params.autoHeight) {
	    suffixes.push('autoheight');
	  }

	  if (rtl) {
	    suffixes.push('rtl');
	  }

	  if (params.slidesPerColumn > 1) {
	    suffixes.push('multirow');

	    if (params.slidesPerColumnFill === 'column') {
	      suffixes.push('multirow-column');
	    }
	  }

	  if (device.android) {
	    suffixes.push('android');
	  }

	  if (device.ios) {
	    suffixes.push('ios');
	  }

	  if (params.cssMode) {
	    suffixes.push('css-mode');
	  }

	  suffixes.forEach(function (suffix) {
	    classNames.push(params.containerModifierClass + suffix);
	  });
	  $el.addClass(classNames.join(' '));
	  swiper.emitContainerClasses();
	}

	function removeClasses() {
	  var swiper = this;
	  var $el = swiper.$el,
	      classNames = swiper.classNames;
	  $el.removeClass(classNames.join(' '));
	  swiper.emitContainerClasses();
	}

	var classes = {
	  addClasses: addClasses,
	  removeClasses: removeClasses
	};

	function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
	  var window = getWindow();
	  var image;

	  function onReady() {
	    if (callback) callback();
	  }

	  var isPicture = $(imageEl).parent('picture')[0];

	  if (!isPicture && (!imageEl.complete || !checkForComplete)) {
	    if (src) {
	      image = new window.Image();
	      image.onload = onReady;
	      image.onerror = onReady;

	      if (sizes) {
	        image.sizes = sizes;
	      }

	      if (srcset) {
	        image.srcset = srcset;
	      }

	      if (src) {
	        image.src = src;
	      }
	    } else {
	      onReady();
	    }
	  } else {
	    // image already loaded...
	    onReady();
	  }
	}

	function preloadImages() {
	  var swiper = this;
	  swiper.imagesToLoad = swiper.$el.find('img');

	  function onReady() {
	    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
	    if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;

	    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
	      if (swiper.params.updateOnImagesReady) swiper.update();
	      swiper.emit('imagesReady');
	    }
	  }

	  for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
	    var imageEl = swiper.imagesToLoad[i];
	    swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
	  }
	}

	var images = {
	  loadImage: loadImage,
	  preloadImages: preloadImages
	};

	function checkOverflow() {
	  var swiper = this;
	  var params = swiper.params;
	  var wasLocked = swiper.isLocked;
	  var lastSlidePosition = swiper.slides.length > 0 && params.slidesOffsetBefore + params.spaceBetween * (swiper.slides.length - 1) + swiper.slides[0].offsetWidth * swiper.slides.length;

	  if (params.slidesOffsetBefore && params.slidesOffsetAfter && lastSlidePosition) {
	    swiper.isLocked = lastSlidePosition <= swiper.size;
	  } else {
	    swiper.isLocked = swiper.snapGrid.length === 1;
	  }

	  swiper.allowSlideNext = !swiper.isLocked;
	  swiper.allowSlidePrev = !swiper.isLocked; // events

	  if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');

	  if (wasLocked && wasLocked !== swiper.isLocked) {
	    swiper.isEnd = false;
	    if (swiper.navigation) swiper.navigation.update();
	  }
	}

	var checkOverflow$1 = {
	  checkOverflow: checkOverflow
	};

	var defaults = {
	  init: true,
	  direction: 'horizontal',
	  touchEventsTarget: 'container',
	  initialSlide: 0,
	  speed: 300,
	  cssMode: false,
	  updateOnWindowResize: true,
	  nested: false,
	  // Overrides
	  width: null,
	  height: null,
	  //
	  preventInteractionOnTransition: false,
	  // ssr
	  userAgent: null,
	  url: null,
	  // To support iOS's swipe-to-go-back gesture (when being used in-app).
	  edgeSwipeDetection: false,
	  edgeSwipeThreshold: 20,
	  // Free mode
	  freeMode: false,
	  freeModeMomentum: true,
	  freeModeMomentumRatio: 1,
	  freeModeMomentumBounce: true,
	  freeModeMomentumBounceRatio: 1,
	  freeModeMomentumVelocityRatio: 1,
	  freeModeSticky: false,
	  freeModeMinimumVelocity: 0.02,
	  // Autoheight
	  autoHeight: false,
	  // Set wrapper width
	  setWrapperSize: false,
	  // Virtual Translate
	  virtualTranslate: false,
	  // Effects
	  effect: 'slide',
	  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
	  // Breakpoints
	  breakpoints: undefined,
	  // Slides grid
	  spaceBetween: 0,
	  slidesPerView: 1,
	  slidesPerColumn: 1,
	  slidesPerColumnFill: 'column',
	  slidesPerGroup: 1,
	  slidesPerGroupSkip: 0,
	  centeredSlides: false,
	  centeredSlidesBounds: false,
	  slidesOffsetBefore: 0,
	  // in px
	  slidesOffsetAfter: 0,
	  // in px
	  normalizeSlideIndex: true,
	  centerInsufficientSlides: false,
	  // Disable swiper and hide navigation when container not overflow
	  watchOverflow: false,
	  // Round length
	  roundLengths: false,
	  // Touches
	  touchRatio: 1,
	  touchAngle: 45,
	  simulateTouch: true,
	  shortSwipes: true,
	  longSwipes: true,
	  longSwipesRatio: 0.5,
	  longSwipesMs: 300,
	  followFinger: true,
	  allowTouchMove: true,
	  threshold: 0,
	  touchMoveStopPropagation: false,
	  touchStartPreventDefault: true,
	  touchStartForcePreventDefault: false,
	  touchReleaseOnEdges: false,
	  // Unique Navigation Elements
	  uniqueNavElements: true,
	  // Resistance
	  resistance: true,
	  resistanceRatio: 0.85,
	  // Progress
	  watchSlidesProgress: false,
	  watchSlidesVisibility: false,
	  // Cursor
	  grabCursor: false,
	  // Clicks
	  preventClicks: true,
	  preventClicksPropagation: true,
	  slideToClickedSlide: false,
	  // Images
	  preloadImages: true,
	  updateOnImagesReady: true,
	  // loop
	  loop: false,
	  loopAdditionalSlides: 0,
	  loopedSlides: null,
	  loopFillGroupWithBlank: false,
	  loopPreventsSlide: true,
	  // Swiping/no swiping
	  allowSlidePrev: true,
	  allowSlideNext: true,
	  swipeHandler: null,
	  // '.swipe-handler',
	  noSwiping: true,
	  noSwipingClass: 'swiper-no-swiping',
	  noSwipingSelector: null,
	  // Passive Listeners
	  passiveListeners: true,
	  // NS
	  containerModifierClass: 'swiper-container-',
	  // NEW
	  slideClass: 'swiper-slide',
	  slideBlankClass: 'swiper-slide-invisible-blank',
	  slideActiveClass: 'swiper-slide-active',
	  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
	  slideVisibleClass: 'swiper-slide-visible',
	  slideDuplicateClass: 'swiper-slide-duplicate',
	  slideNextClass: 'swiper-slide-next',
	  slideDuplicateNextClass: 'swiper-slide-duplicate-next',
	  slidePrevClass: 'swiper-slide-prev',
	  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
	  wrapperClass: 'swiper-wrapper',
	  // Callbacks
	  runCallbacksOnInit: true,
	  // Internals
	  _emitClasses: false
	};

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
	var prototypes = {
	  modular: modular,
	  eventsEmitter: eventsEmitter,
	  update: update$1,
	  translate: translate,
	  transition: transition$1,
	  slide: slide,
	  loop: loop,
	  grabCursor: grabCursor,
	  manipulation: manipulation,
	  events: events,
	  breakpoints: breakpoints,
	  checkOverflow: checkOverflow$1,
	  classes: classes,
	  images: images
	};
	var extendedDefaults = {};

	var Swiper = /*#__PURE__*/function () {
	  function Swiper() {
	    var el;
	    var params;

	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {
	      params = args[0];
	    } else {
	      el = args[0];
	      params = args[1];
	    }

	    if (!params) params = {};
	    params = extend$1({}, params);
	    if (el && !params.el) params.el = el; // Swiper Instance

	    var swiper = this;
	    swiper.support = getSupport();
	    swiper.device = getDevice({
	      userAgent: params.userAgent
	    });
	    swiper.browser = getBrowser();
	    swiper.eventsListeners = {};
	    swiper.eventsAnyListeners = [];

	    if (typeof swiper.modules === 'undefined') {
	      swiper.modules = {};
	    }

	    Object.keys(swiper.modules).forEach(function (moduleName) {
	      var module = swiper.modules[moduleName];

	      if (module.params) {
	        var moduleParamName = Object.keys(module.params)[0];
	        var moduleParams = module.params[moduleParamName];
	        if (typeof moduleParams !== 'object' || moduleParams === null) return;
	        if (!(moduleParamName in params && 'enabled' in moduleParams)) return;

	        if (params[moduleParamName] === true) {
	          params[moduleParamName] = {
	            enabled: true
	          };
	        }

	        if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
	          params[moduleParamName].enabled = true;
	        }

	        if (!params[moduleParamName]) params[moduleParamName] = {
	          enabled: false
	        };
	      }
	    }); // Extend defaults with modules params

	    var swiperParams = extend$1({}, defaults);
	    swiper.useParams(swiperParams); // Extend defaults with passed params

	    swiper.params = extend$1({}, swiperParams, extendedDefaults, params);
	    swiper.originalParams = extend$1({}, swiper.params);
	    swiper.passedParams = extend$1({}, params); // add event listeners

	    if (swiper.params && swiper.params.on) {
	      Object.keys(swiper.params.on).forEach(function (eventName) {
	        swiper.on(eventName, swiper.params.on[eventName]);
	      });
	    }

	    if (swiper.params && swiper.params.onAny) {
	      swiper.onAny(swiper.params.onAny);
	    } // Save Dom lib


	    swiper.$ = $; // Find el

	    var $el = $(swiper.params.el);
	    el = $el[0];

	    if (!el) {
	      return undefined;
	    }

	    if ($el.length > 1) {
	      var swipers = [];
	      $el.each(function (containerEl) {
	        var newParams = extend$1({}, params, {
	          el: containerEl
	        });
	        swipers.push(new Swiper(newParams));
	      });
	      return swipers;
	    }

	    el.swiper = swiper; // Find Wrapper

	    var $wrapperEl;

	    if (el && el.shadowRoot && el.shadowRoot.querySelector) {
	      $wrapperEl = $(el.shadowRoot.querySelector("." + swiper.params.wrapperClass)); // Children needs to return slot items

	      $wrapperEl.children = function (options) {
	        return $el.children(options);
	      };
	    } else {
	      $wrapperEl = $el.children("." + swiper.params.wrapperClass);
	    } // Extend Swiper


	    extend$1(swiper, {
	      $el: $el,
	      el: el,
	      $wrapperEl: $wrapperEl,
	      wrapperEl: $wrapperEl[0],
	      // Classes
	      classNames: [],
	      // Slides
	      slides: $(),
	      slidesGrid: [],
	      snapGrid: [],
	      slidesSizesGrid: [],
	      // isDirection
	      isHorizontal: function isHorizontal() {
	        return swiper.params.direction === 'horizontal';
	      },
	      isVertical: function isVertical() {
	        return swiper.params.direction === 'vertical';
	      },
	      // RTL
	      rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
	      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
	      wrongRTL: $wrapperEl.css('display') === '-webkit-box',
	      // Indexes
	      activeIndex: 0,
	      realIndex: 0,
	      //
	      isBeginning: true,
	      isEnd: false,
	      // Props
	      translate: 0,
	      previousTranslate: 0,
	      progress: 0,
	      velocity: 0,
	      animating: false,
	      // Locks
	      allowSlideNext: swiper.params.allowSlideNext,
	      allowSlidePrev: swiper.params.allowSlidePrev,
	      // Touch Events
	      touchEvents: function touchEvents() {
	        var touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
	        var desktop = ['mousedown', 'mousemove', 'mouseup'];

	        if (swiper.support.pointerEvents) {
	          desktop = ['pointerdown', 'pointermove', 'pointerup'];
	        }

	        swiper.touchEventsTouch = {
	          start: touch[0],
	          move: touch[1],
	          end: touch[2],
	          cancel: touch[3]
	        };
	        swiper.touchEventsDesktop = {
	          start: desktop[0],
	          move: desktop[1],
	          end: desktop[2]
	        };
	        return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
	      }(),
	      touchEventsData: {
	        isTouched: undefined,
	        isMoved: undefined,
	        allowTouchCallbacks: undefined,
	        touchStartTime: undefined,
	        isScrolling: undefined,
	        currentTranslate: undefined,
	        startTranslate: undefined,
	        allowThresholdMove: undefined,
	        // Form elements to match
	        formElements: 'input, select, option, textarea, button, video, label',
	        // Last click time
	        lastClickTime: now(),
	        clickTimeout: undefined,
	        // Velocities
	        velocities: [],
	        allowMomentumBounce: undefined,
	        isTouchEvent: undefined,
	        startMoving: undefined
	      },
	      // Clicks
	      allowClick: true,
	      // Touches
	      allowTouchMove: swiper.params.allowTouchMove,
	      touches: {
	        startX: 0,
	        startY: 0,
	        currentX: 0,
	        currentY: 0,
	        diff: 0
	      },
	      // Images
	      imagesToLoad: [],
	      imagesLoaded: 0
	    }); // Install Modules

	    swiper.useModules();
	    swiper.emit('_swiper'); // Init

	    if (swiper.params.init) {
	      swiper.init();
	    } // Return app instance


	    return swiper;
	  }

	  var _proto = Swiper.prototype;

	  _proto.emitContainerClasses = function emitContainerClasses() {
	    var swiper = this;
	    if (!swiper.params._emitClasses || !swiper.el) return;
	    var classes = swiper.el.className.split(' ').filter(function (className) {
	      return className.indexOf('swiper-container') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
	    });
	    swiper.emit('_containerClasses', classes.join(' '));
	  };

	  _proto.getSlideClasses = function getSlideClasses(slideEl) {
	    var swiper = this;
	    return slideEl.className.split(' ').filter(function (className) {
	      return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
	    }).join(' ');
	  };

	  _proto.emitSlidesClasses = function emitSlidesClasses() {
	    var swiper = this;
	    if (!swiper.params._emitClasses || !swiper.el) return;
	    swiper.slides.each(function (slideEl) {
	      var classNames = swiper.getSlideClasses(slideEl);
	      swiper.emit('_slideClass', slideEl, classNames);
	    });
	  };

	  _proto.slidesPerViewDynamic = function slidesPerViewDynamic() {
	    var swiper = this;
	    var params = swiper.params,
	        slides = swiper.slides,
	        slidesGrid = swiper.slidesGrid,
	        swiperSize = swiper.size,
	        activeIndex = swiper.activeIndex;
	    var spv = 1;

	    if (params.centeredSlides) {
	      var slideSize = slides[activeIndex].swiperSlideSize;
	      var breakLoop;

	      for (var i = activeIndex + 1; i < slides.length; i += 1) {
	        if (slides[i] && !breakLoop) {
	          slideSize += slides[i].swiperSlideSize;
	          spv += 1;
	          if (slideSize > swiperSize) breakLoop = true;
	        }
	      }

	      for (var _i = activeIndex - 1; _i >= 0; _i -= 1) {
	        if (slides[_i] && !breakLoop) {
	          slideSize += slides[_i].swiperSlideSize;
	          spv += 1;
	          if (slideSize > swiperSize) breakLoop = true;
	        }
	      }
	    } else {
	      for (var _i2 = activeIndex + 1; _i2 < slides.length; _i2 += 1) {
	        if (slidesGrid[_i2] - slidesGrid[activeIndex] < swiperSize) {
	          spv += 1;
	        }
	      }
	    }

	    return spv;
	  };

	  _proto.update = function update() {
	    var swiper = this;
	    if (!swiper || swiper.destroyed) return;
	    var snapGrid = swiper.snapGrid,
	        params = swiper.params; // Breakpoints

	    if (params.breakpoints) {
	      swiper.setBreakpoint();
	    }

	    swiper.updateSize();
	    swiper.updateSlides();
	    swiper.updateProgress();
	    swiper.updateSlidesClasses();

	    function setTranslate() {
	      var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
	      var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
	      swiper.setTranslate(newTranslate);
	      swiper.updateActiveIndex();
	      swiper.updateSlidesClasses();
	    }

	    var translated;

	    if (swiper.params.freeMode) {
	      setTranslate();

	      if (swiper.params.autoHeight) {
	        swiper.updateAutoHeight();
	      }
	    } else {
	      if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
	        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
	      } else {
	        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
	      }

	      if (!translated) {
	        setTranslate();
	      }
	    }

	    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
	      swiper.checkOverflow();
	    }

	    swiper.emit('update');
	  };

	  _proto.changeDirection = function changeDirection(newDirection, needUpdate) {
	    if (needUpdate === void 0) {
	      needUpdate = true;
	    }

	    var swiper = this;
	    var currentDirection = swiper.params.direction;

	    if (!newDirection) {
	      // eslint-disable-next-line
	      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
	    }

	    if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
	      return swiper;
	    }

	    swiper.$el.removeClass("" + swiper.params.containerModifierClass + currentDirection).addClass("" + swiper.params.containerModifierClass + newDirection);
	    swiper.emitContainerClasses();
	    swiper.params.direction = newDirection;
	    swiper.slides.each(function (slideEl) {
	      if (newDirection === 'vertical') {
	        slideEl.style.width = '';
	      } else {
	        slideEl.style.height = '';
	      }
	    });
	    swiper.emit('changeDirection');
	    if (needUpdate) swiper.update();
	    return swiper;
	  };

	  _proto.init = function init() {
	    var swiper = this;
	    if (swiper.initialized) return;
	    swiper.emit('beforeInit'); // Set breakpoint

	    if (swiper.params.breakpoints) {
	      swiper.setBreakpoint();
	    } // Add Classes


	    swiper.addClasses(); // Create loop

	    if (swiper.params.loop) {
	      swiper.loopCreate();
	    } // Update size


	    swiper.updateSize(); // Update slides

	    swiper.updateSlides();

	    if (swiper.params.watchOverflow) {
	      swiper.checkOverflow();
	    } // Set Grab Cursor


	    if (swiper.params.grabCursor) {
	      swiper.setGrabCursor();
	    }

	    if (swiper.params.preloadImages) {
	      swiper.preloadImages();
	    } // Slide To Initial Slide


	    if (swiper.params.loop) {
	      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
	    } else {
	      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
	    } // Attach events


	    swiper.attachEvents(); // Init Flag

	    swiper.initialized = true; // Emit

	    swiper.emit('init');
	    swiper.emit('afterInit');
	  };

	  _proto.destroy = function destroy(deleteInstance, cleanStyles) {
	    if (deleteInstance === void 0) {
	      deleteInstance = true;
	    }

	    if (cleanStyles === void 0) {
	      cleanStyles = true;
	    }

	    var swiper = this;
	    var params = swiper.params,
	        $el = swiper.$el,
	        $wrapperEl = swiper.$wrapperEl,
	        slides = swiper.slides;

	    if (typeof swiper.params === 'undefined' || swiper.destroyed) {
	      return null;
	    }

	    swiper.emit('beforeDestroy'); // Init Flag

	    swiper.initialized = false; // Detach events

	    swiper.detachEvents(); // Destroy loop

	    if (params.loop) {
	      swiper.loopDestroy();
	    } // Cleanup styles


	    if (cleanStyles) {
	      swiper.removeClasses();
	      $el.removeAttr('style');
	      $wrapperEl.removeAttr('style');

	      if (slides && slides.length) {
	        slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
	      }
	    }

	    swiper.emit('destroy'); // Detach emitter events

	    Object.keys(swiper.eventsListeners).forEach(function (eventName) {
	      swiper.off(eventName);
	    });

	    if (deleteInstance !== false) {
	      swiper.$el[0].swiper = null;
	      deleteProps(swiper);
	    }

	    swiper.destroyed = true;
	    return null;
	  };

	  Swiper.extendDefaults = function extendDefaults(newDefaults) {
	    extend$1(extendedDefaults, newDefaults);
	  };

	  Swiper.installModule = function installModule(module) {
	    if (!Swiper.prototype.modules) Swiper.prototype.modules = {};
	    var name = module.name || Object.keys(Swiper.prototype.modules).length + "_" + now();
	    Swiper.prototype.modules[name] = module;
	  };

	  Swiper.use = function use(module) {
	    if (Array.isArray(module)) {
	      module.forEach(function (m) {
	        return Swiper.installModule(m);
	      });
	      return Swiper;
	    }

	    Swiper.installModule(module);
	    return Swiper;
	  };

	  _createClass(Swiper, null, [{
	    key: "extendedDefaults",
	    get: function get() {
	      return extendedDefaults;
	    }
	  }, {
	    key: "defaults",
	    get: function get() {
	      return defaults;
	    }
	  }]);

	  return Swiper;
	}();

	Object.keys(prototypes).forEach(function (prototypeGroup) {
	  Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {
	    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
	  });
	});
	Swiper.use([Resize, Observer$1]);

	/* src/components/Gallery.svelte generated by Svelte v3.30.0 */
	const file$3 = "src/components/Gallery.svelte";

	function get_each_context$1(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[9] = list[i];
		child_ctx[11] = i;
		return child_ctx;
	}

	const get_default_slot_changes$1 = dirty => ({ prop: dirty & /*images*/ 1 });
	const get_default_slot_context$1 = ctx => ({ prop: [/*image*/ ctx[9], /*i*/ ctx[11]] });

	// (66:2) {#each images as image, i}
	function create_each_block$1(ctx) {
		let div;
		let t;
		let current;
		const default_slot_template = /*#slots*/ ctx[5].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], get_default_slot_context$1);

		const block = {
			c: function create() {
				div = element("div");
				if (default_slot) default_slot.c();
				t = space();
				attr_dev(div, "class", "swiper-slide svelte-14so8i1");
				add_location(div, file$3, 66, 12, 1513);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				append_dev(div, t);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && dirty & /*$$scope, images*/ 17) {
						update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, get_default_slot_changes$1, get_default_slot_context$1);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) detach_dev(div);
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$1.name,
			type: "each",
			source: "(66:2) {#each images as image, i}",
			ctx
		});

		return block;
	}

	function create_fragment$5(ctx) {
		let div1;
		let div0;
		let t0;
		let button0;
		let t1;
		let button1;
		let current;
		let mounted;
		let dispose;
		let each_value = /*images*/ ctx[0];
		validate_each_argument(each_value);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				div1 = element("div");
				div0 = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t0 = space();
				button0 = element("button");
				t1 = space();
				button1 = element("button");
				attr_dev(div0, "class", "swiper-wrapper");
				add_location(div0, file$3, 64, 1, 1443);
				attr_dev(button0, "title", "Vorheriges Bild");
				attr_dev(button0, "class", "button prev svelte-14so8i1");
				add_location(button0, file$3, 72, 4, 1630);
				attr_dev(button1, "title", "Nächstes Bild");
				attr_dev(button1, "class", "button next svelte-14so8i1");
				add_location(button1, file$3, 73, 4, 1726);
				attr_dev(div1, "class", "swiper-container svelte-14so8i1");
				add_location(div1, file$3, 62, 0, 1388);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div1, anchor);
				append_dev(div1, div0);

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(div0, null);
				}

				append_dev(div1, t0);
				append_dev(div1, button0);
				append_dev(div1, t1);
				append_dev(div1, button1);
				/*div1_binding*/ ctx[6](div1);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(window, "keydown", /*handleKeydown*/ ctx[3], false, false, false),
						listen_dev(
							button0,
							"click",
							function () {
								if (is_function(/*swiper*/ ctx[2].slidePrev())) /*swiper*/ ctx[2].slidePrev().apply(this, arguments);
							},
							false,
							false,
							false
						),
						listen_dev(
							button1,
							"click",
							function () {
								if (is_function(/*swiper*/ ctx[2].slideNext())) /*swiper*/ ctx[2].slideNext().apply(this, arguments);
							},
							false,
							false,
							false
						)
					];

					mounted = true;
				}
			},
			p: function update(new_ctx, [dirty]) {
				ctx = new_ctx;

				if (dirty & /*$$scope, images*/ 17) {
					each_value = /*images*/ ctx[0];
					validate_each_argument(each_value);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$1(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$1(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div0, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) detach_dev(div1);
				destroy_each(each_blocks, detaching);
				/*div1_binding*/ ctx[6](null);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$5.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function slideHook(n, max) {
		let i = n % max - 1;

		if (i < 0) {
			i = max - 1;
		} else if (i >= max) {
			i = 0;
		}

		return i;
	}

	function instance$5($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots("Gallery", slots, ['default']);
		let { images } = $$props;
		let index = 0;
		let container;
		let swiper;
		const dispatch = createEventDispatcher();

		onMount(() => {
			$$invalidate(2, swiper = new Swiper(container,
			{
					loop: true,
					speed: 400,
					on: {
						slideChange(event) {
							index = slideHook(parseInt(this.activeIndex), images.length);
							dispatch("slide", { index });
						}
					}
				}));

			return () => {
				swiper.destroy();
				$$invalidate(2, swiper = undefined);
			};
		});

		function handleKeydown(event) {
			switch (event.code) {
				case "ArrowLeft":
				case "KeyA":
					swiper.slidePrev();
					break;
				case "ArrowRight":
				case "KeyD":
				case "Space":
				case "Enter":
					swiper.slideNext();
					break;
			}
		}

		const writable_props = ["images"];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Gallery> was created with unknown prop '${key}'`);
		});

		function div1_binding($$value) {
			binding_callbacks[$$value ? "unshift" : "push"](() => {
				container = $$value;
				$$invalidate(1, container);
			});
		}

		$$self.$$set = $$props => {
			if ("images" in $$props) $$invalidate(0, images = $$props.images);
			if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
		};

		$$self.$capture_state = () => ({
			onMount,
			createEventDispatcher,
			Swiper,
			images,
			index,
			container,
			swiper,
			dispatch,
			slideHook,
			handleKeydown
		});

		$$self.$inject_state = $$props => {
			if ("images" in $$props) $$invalidate(0, images = $$props.images);
			if ("index" in $$props) index = $$props.index;
			if ("container" in $$props) $$invalidate(1, container = $$props.container);
			if ("swiper" in $$props) $$invalidate(2, swiper = $$props.swiper);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [images, container, swiper, handleKeydown, $$scope, slots, div1_binding];
	}

	class Gallery extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$5, create_fragment$5, safe_not_equal, { images: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Gallery",
				options,
				id: create_fragment$5.name
			});

			const { ctx } = this.$$;
			const props = options.props || {};

			if (/*images*/ ctx[0] === undefined && !("images" in props)) {
				console.warn("<Gallery> was created without expected prop 'images'");
			}
		}

		get images() {
			throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set images(value) {
			throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/routes/Project.svelte generated by Svelte v3.30.0 */
	const file$4 = "src/routes/Project.svelte";

	// (22:8) {#if project.images[index]}
	function create_if_block$2(ctx) {
		let h2;
		let t_value = /*project*/ ctx[0].images[/*index*/ ctx[1]].alt + "";
		let t;

		const block = {
			c: function create() {
				h2 = element("h2");
				t = text(t_value);
				attr_dev(h2, "class", "svelte-1k1sdsi");
				add_location(h2, file$4, 22, 12, 470);
			},
			m: function mount(target, anchor) {
				insert_dev(target, h2, anchor);
				append_dev(h2, t);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*project, index*/ 3 && t_value !== (t_value = /*project*/ ctx[0].images[/*index*/ ctx[1]].alt + "")) set_data_dev(t, t_value);
			},
			d: function destroy(detaching) {
				if (detaching) detach_dev(h2);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$2.name,
			type: "if",
			source: "(22:8) {#if project.images[index]}",
			ctx
		});

		return block;
	}

	// (28:8) <Link to="/">
	function create_default_slot_1$1(ctx) {
		let t;

		const block = {
			c: function create() {
				t = text("Index");
			},
			m: function mount(target, anchor) {
				insert_dev(target, t, anchor);
			},
			d: function destroy(detaching) {
				if (detaching) detach_dev(t);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_1$1.name,
			type: "slot",
			source: "(28:8) <Link to=\\\"/\\\">",
			ctx
		});

		return block;
	}

	// (32:8) <Gallery images={project.images} let:prop={[image,i]} on:slide={handleSlide}>
	function create_default_slot$1(ctx) {
		let figure;
		let div;
		let img;
		let figure_title_value;
		let current;

		img = new Img({
				props: {
					srcset: /*image*/ ctx[3].srcset,
					alt: /*image*/ ctx[3].alt
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				figure = element("figure");
				div = element("div");
				create_component(img.$$.fragment);
				attr_dev(div, "class", "square svelte-1k1sdsi");
				add_location(div, file$4, 33, 16, 755);
				attr_dev(figure, "title", figure_title_value = /*image*/ ctx[3].alt);
				attr_dev(figure, "class", "svelte-1k1sdsi");
				add_location(figure, file$4, 32, 12, 710);
			},
			m: function mount(target, anchor) {
				insert_dev(target, figure, anchor);
				append_dev(figure, div);
				mount_component(img, div, null);
				current = true;
			},
			p: function update(ctx, dirty) {
				const img_changes = {};
				if (dirty & /*image*/ 8) img_changes.srcset = /*image*/ ctx[3].srcset;
				if (dirty & /*image*/ 8) img_changes.alt = /*image*/ ctx[3].alt;
				img.$set(img_changes);

				if (!current || dirty & /*image*/ 8 && figure_title_value !== (figure_title_value = /*image*/ ctx[3].alt)) {
					attr_dev(figure, "title", figure_title_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(img.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(img.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) detach_dev(figure);
				destroy_component(img);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$1.name,
			type: "slot",
			source: "(32:8) <Gallery images={project.images} let:prop={[image,i]} on:slide={handleSlide}>",
			ctx
		});

		return block;
	}

	function create_fragment$6(ctx) {
		let article;
		let header;
		let p0;
		let t0_value = /*project*/ ctx[0].n + "";
		let t0;
		let t1;
		let p1;
		let t2_value = /*index*/ ctx[1] + 1 + "";
		let t2;
		let t3;
		let t4_value = /*project*/ ctx[0].images.length + "";
		let t4;
		let t5;
		let t6;
		let footer;
		let link;
		let t7;
		let section;
		let gallery;
		let current;
		let if_block = /*project*/ ctx[0].images[/*index*/ ctx[1]] && create_if_block$2(ctx);

		link = new Link({
				props: {
					to: "/",
					$$slots: { default: [create_default_slot_1$1] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		gallery = new Gallery({
				props: {
					images: /*project*/ ctx[0].images,
					$$slots: {
						default: [
							create_default_slot$1,
							({ prop: [image, i] }) => ({ 3: image, 4: i }),
							({ prop: image_i }) => (image_i ? 8 : 0) | (image_i ? 16 : 0)
						]
					},
					$$scope: { ctx }
				},
				$$inline: true
			});

		gallery.$on("slide", /*handleSlide*/ ctx[2]);

		const block = {
			c: function create() {
				article = element("article");
				header = element("header");
				p0 = element("p");
				t0 = text(t0_value);
				t1 = space();
				p1 = element("p");
				t2 = text(t2_value);
				t3 = text("/");
				t4 = text(t4_value);
				t5 = space();
				if (if_block) if_block.c();
				t6 = space();
				footer = element("footer");
				create_component(link.$$.fragment);
				t7 = space();
				section = element("section");
				create_component(gallery.$$.fragment);
				attr_dev(p0, "class", "i num svelte-1k1sdsi");
				add_location(p0, file$4, 19, 8, 320);
				attr_dev(p1, "class", "index num svelte-1k1sdsi");
				add_location(p1, file$4, 20, 8, 361);
				attr_dev(header, "class", "svelte-1k1sdsi");
				add_location(header, file$4, 18, 4, 303);
				attr_dev(footer, "class", "svelte-1k1sdsi");
				add_location(footer, file$4, 26, 4, 540);
				attr_dev(section, "class", "svelte-1k1sdsi");
				add_location(section, file$4, 30, 4, 602);
				add_location(article, file$4, 16, 0, 288);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, article, anchor);
				append_dev(article, header);
				append_dev(header, p0);
				append_dev(p0, t0);
				append_dev(header, t1);
				append_dev(header, p1);
				append_dev(p1, t2);
				append_dev(p1, t3);
				append_dev(p1, t4);
				append_dev(header, t5);
				if (if_block) if_block.m(header, null);
				append_dev(article, t6);
				append_dev(article, footer);
				mount_component(link, footer, null);
				append_dev(article, t7);
				append_dev(article, section);
				mount_component(gallery, section, null);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				if ((!current || dirty & /*project*/ 1) && t0_value !== (t0_value = /*project*/ ctx[0].n + "")) set_data_dev(t0, t0_value);
				if ((!current || dirty & /*index*/ 2) && t2_value !== (t2_value = /*index*/ ctx[1] + 1 + "")) set_data_dev(t2, t2_value);
				if ((!current || dirty & /*project*/ 1) && t4_value !== (t4_value = /*project*/ ctx[0].images.length + "")) set_data_dev(t4, t4_value);

				if (/*project*/ ctx[0].images[/*index*/ ctx[1]]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$2(ctx);
						if_block.c();
						if_block.m(header, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				const link_changes = {};

				if (dirty & /*$$scope*/ 32) {
					link_changes.$$scope = { dirty, ctx };
				}

				link.$set(link_changes);
				const gallery_changes = {};
				if (dirty & /*project*/ 1) gallery_changes.images = /*project*/ ctx[0].images;

				if (dirty & /*$$scope, image*/ 40) {
					gallery_changes.$$scope = { dirty, ctx };
				}

				gallery.$set(gallery_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(link.$$.fragment, local);
				transition_in(gallery.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(link.$$.fragment, local);
				transition_out(gallery.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) detach_dev(article);
				if (if_block) if_block.d();
				destroy_component(link);
				destroy_component(gallery);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$6.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$6($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots("Project", slots, []);
		let { project } = $$props;
		let index;

		function handleSlide(event) {
			$$invalidate(1, index = event.detail.index);
		}

		const writable_props = ["project"];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Project> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ("project" in $$props) $$invalidate(0, project = $$props.project);
		};

		$$self.$capture_state = () => ({
			Link,
			Img,
			Gallery,
			project,
			index,
			handleSlide
		});

		$$self.$inject_state = $$props => {
			if ("project" in $$props) $$invalidate(0, project = $$props.project);
			if ("index" in $$props) $$invalidate(1, index = $$props.index);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [project, index, handleSlide];
	}

	class Project extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$6, create_fragment$6, safe_not_equal, { project: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Project",
				options,
				id: create_fragment$6.name
			});

			const { ctx } = this.$$;
			const props = options.props || {};

			if (/*project*/ ctx[0] === undefined && !("project" in props)) {
				console.warn("<Project> was created without expected prop 'project'");
			}
		}

		get project() {
			throw new Error("<Project>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set project(value) {
			throw new Error("<Project>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/routes/Imprint.svelte generated by Svelte v3.30.0 */
	const file$5 = "src/routes/Imprint.svelte";

	// (10:4) <Link to="/">
	function create_default_slot$2(ctx) {
		let t;

		const block = {
			c: function create() {
				t = text("Index");
			},
			m: function mount(target, anchor) {
				insert_dev(target, t, anchor);
			},
			d: function destroy(detaching) {
				if (detaching) detach_dev(t);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$2.name,
			type: "slot",
			source: "(10:4) <Link to=\\\"/\\\">",
			ctx
		});

		return block;
	}

	function create_fragment$7(ctx) {
		let main;
		let link;
		let t;
		let aside;
		let current;

		link = new Link({
				props: {
					to: "/",
					$$slots: { default: [create_default_slot$2] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				main = element("main");
				create_component(link.$$.fragment);
				t = space();
				aside = element("aside");
				attr_dev(aside, "class", "text svelte-12fm9x0");
				add_location(aside, file$5, 11, 4, 129);
				attr_dev(main, "class", "svelte-12fm9x0");
				add_location(main, file$5, 7, 0, 86);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, main, anchor);
				mount_component(link, main, null);
				append_dev(main, t);
				append_dev(main, aside);
				aside.innerHTML = /*text*/ ctx[0];
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const link_changes = {};

				if (dirty & /*$$scope*/ 2) {
					link_changes.$$scope = { dirty, ctx };
				}

				link.$set(link_changes);
				if (!current || dirty & /*text*/ 1) aside.innerHTML = /*text*/ ctx[0];		},
			i: function intro(local) {
				if (current) return;
				transition_in(link.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(link.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) detach_dev(main);
				destroy_component(link);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$7.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$7($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots("Imprint", slots, []);
		let { text } = $$props;
		const writable_props = ["text"];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Imprint> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ("text" in $$props) $$invalidate(0, text = $$props.text);
		};

		$$self.$capture_state = () => ({ Link, text });

		$$self.$inject_state = $$props => {
			if ("text" in $$props) $$invalidate(0, text = $$props.text);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [text];
	}

	class Imprint extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$7, create_fragment$7, safe_not_equal, { text: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Imprint",
				options,
				id: create_fragment$7.name
			});

			const { ctx } = this.$$;
			const props = options.props || {};

			if (/*text*/ ctx[0] === undefined && !("text" in props)) {
				console.warn("<Imprint> was created without expected prop 'text'");
			}
		}

		get text() {
			throw new Error("<Imprint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set text(value) {
			throw new Error("<Imprint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/App.svelte generated by Svelte v3.30.0 */

	// (19:1) <Route path="portfolio/:id" let:params>
	function create_default_slot_1$2(ctx) {
		let project;
		let current;

		project = new Project({
				props: {
					project: getProject(/*data*/ ctx[0].pages, "portfolio/" + /*params*/ ctx[2].id)
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(project.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(project, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const project_changes = {};
				if (dirty & /*data, params*/ 5) project_changes.project = getProject(/*data*/ ctx[0].pages, "portfolio/" + /*params*/ ctx[2].id);
				project.$set(project_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(project.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(project.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(project, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_1$2.name,
			type: "slot",
			source: "(19:1) <Route path=\\\"portfolio/:id\\\" let:params>",
			ctx
		});

		return block;
	}

	// (15:0) <Router url="{url}">
	function create_default_slot$3(ctx) {
		let route0;
		let t0;
		let route1;
		let t1;
		let route2;
		let current;

		route0 = new Route({
				props: {
					path: "/",
					component: Index,
					data: /*data*/ ctx[0]
				},
				$$inline: true
			});

		route1 = new Route({
				props: {
					path: "impressum",
					component: Imprint,
					text: /*data*/ ctx[0].imprint
				},
				$$inline: true
			});

		route2 = new Route({
				props: {
					path: "portfolio/:id",
					$$slots: {
						default: [
							create_default_slot_1$2,
							({ params }) => ({ 2: params }),
							({ params }) => params ? 4 : 0
						]
					},
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(route0.$$.fragment);
				t0 = space();
				create_component(route1.$$.fragment);
				t1 = space();
				create_component(route2.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(route0, target, anchor);
				insert_dev(target, t0, anchor);
				mount_component(route1, target, anchor);
				insert_dev(target, t1, anchor);
				mount_component(route2, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const route0_changes = {};
				if (dirty & /*data*/ 1) route0_changes.data = /*data*/ ctx[0];
				route0.$set(route0_changes);
				const route1_changes = {};
				if (dirty & /*data*/ 1) route1_changes.text = /*data*/ ctx[0].imprint;
				route1.$set(route1_changes);
				const route2_changes = {};

				if (dirty & /*$$scope, data, params*/ 13) {
					route2_changes.$$scope = { dirty, ctx };
				}

				route2.$set(route2_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(route0.$$.fragment, local);
				transition_in(route1.$$.fragment, local);
				transition_in(route2.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(route0.$$.fragment, local);
				transition_out(route1.$$.fragment, local);
				transition_out(route2.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(route0, detaching);
				if (detaching) detach_dev(t0);
				destroy_component(route1, detaching);
				if (detaching) detach_dev(t1);
				destroy_component(route2, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$3.name,
			type: "slot",
			source: "(15:0) <Router url=\\\"{url}\\\">",
			ctx
		});

		return block;
	}

	function create_fragment$8(ctx) {
		let router;
		let current;

		router = new Router({
				props: {
					url: /*url*/ ctx[1],
					$$slots: { default: [create_default_slot$3] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(router.$$.fragment);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(router, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const router_changes = {};
				if (dirty & /*url*/ 2) router_changes.url = /*url*/ ctx[1];

				if (dirty & /*$$scope, data*/ 9) {
					router_changes.$$scope = { dirty, ctx };
				}

				router.$set(router_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(router.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(router.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(router, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$8.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$8($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots("App", slots, []);
		let { data } = $$props;
		let { url = "" } = $$props;
		const writable_props = ["data", "url"];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ("data" in $$props) $$invalidate(0, data = $$props.data);
			if ("url" in $$props) $$invalidate(1, url = $$props.url);
		};

		$$self.$capture_state = () => ({
			Router,
			Link,
			Route,
			getProject,
			Index,
			Project,
			Imprint,
			data,
			url
		});

		$$self.$inject_state = $$props => {
			if ("data" in $$props) $$invalidate(0, data = $$props.data);
			if ("url" in $$props) $$invalidate(1, url = $$props.url);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [data, url];
	}

	class App extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$8, create_fragment$8, safe_not_equal, { data: 0, url: 1 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "App",
				options,
				id: create_fragment$8.name
			});

			const { ctx } = this.$$;
			const props = options.props || {};

			if (/*data*/ ctx[0] === undefined && !("data" in props)) {
				console.warn("<App> was created without expected prop 'data'");
			}
		}

		get data() {
			throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set data(value) {
			throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get url() {
			throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set url(value) {
			throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	const app = new App({
		target: document.body,
		props: {
			data: window.pageData
		}
	});

	return app;

}());
//# sourceMappingURL=bundle.js.map
